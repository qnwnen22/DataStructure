Tree(트리)는 계층적인 구조를 표현하는 비선형 자료구조입니다. 
트리는 노드(Node)들로 구성되며, 각 노드는 하나의 부모 노드와 여러 개의 자식 노드를 가질 수 있습니다. 
트리는 계층적인 관계를 표현할 때 자주 사용되며, 다양한 응용 분야에서 활용됩니다.

Tree의 주요 연산과 시간 복잡도:

Insertion (삽입):
	1. 새로운 노드를 트리에 삽입합니다.
	2. 시간 복잡도: 평균 및 최악의 경우 𝑂(log⁡𝑛) (균형 트리의 경우), 최악의 경우 𝑂(𝑛) (비균형 트리의 경우)

Deletion (삭제):
	1. 특정 노드를 트리에서 삭제합니다.
	2. 시간 복잡도: 평균 및 최악의 경우 𝑂(log⁡𝑛) (균형 트리의 경우), 최악의 경우 𝑂(𝑛) (비균형 트리의 경우)

Search (탐색):
	1. 특정 값을 가진 노드를 찾습니다.
	2. 시간 복잡도: 평균 및 최악의 경우 𝑂(log⁡𝑛) (균형 트리의 경우), 최악의 경우 𝑂(𝑛) (비균형 트리의 경우)

Tree의 특징:
	1. 계층적 구조: 트리는 계층적인 관계를 자연스럽게 표현할 수 있습니다.
	2. 루트 노드: 트리는 하나의 루트 노드를 가지며, 모든 노드는 루트 노드로부터 시작되는 경로를 가집니다.
	3. 부모-자식 관계: 각 노드는 하나의 부모 노드와 여러 개의 자식 노드를 가질 수 있습니다.
	4. 비선형 구조: 트리는 비선형 자료구조로, 데이터를 계층적으로 표현합니다.

Tree의 장단점:
	장점:
		1. 계층적 표현: 트리는 계층적인 데이터를 효과적으로 표현할 수 있습니다.
		2. 효율적 연산: 균형 트리(예: AVL 트리, 레드-블랙 트리)의 경우, 삽입, 삭제, 탐색 연산의 시간 복잡도가 𝑂(log⁡𝑛)으로 효율적입니다.

	단점:
		1. 복잡한 구현: 트리의 구현은 복잡할 수 있으며, 특히 균형을 유지하는 연산은 추가적인 로직이 필요합니다.
		2. 메모리 오버헤드: 트리는 포인터를 사용하여 노드들을 연결하기 때문에, 추가적인 메모리 오버헤드가 발생할 수 있습니다.
		   트리는 데이터의 계층적 관계를 표현할 때 매우 유용한 자료구조입니다. 
		   그러나 트리의 균형을 유지하는 것은 추가적인 구현을 필요로 하며, 트리의 균형을 유지하지 않으면 연산의 효율성이 저하될 수 있습니다. 
		   따라서, 트리를 사용할 때는 트리의 균형을 유지하는 구현을 선택하는 것이 중요합니다.