12.4 그래프의 탐색

그래프의 정점들을 방문하여 목표 정점을 찾는 것을 그래프의 탐색(Search) 이라 한다.
그래프 탐색은 그래프를 생성, 저장 하는 것과 함께 그래프에서 가장 중요한 연산이라 할 수 있다.
그래프를 탐색하는 방법에는 노드를 방문하는 순서에 따라 깊이 우선 탐색(Depth First Search)과 너비 우선 탐색(Breath First Search)이 있다.

깊이 우선 탐색

깊이 우선 탐색(Depth First Search, DFS)은 자식, 그 자식의 자식 등으로 계속 이동하여 깊은 노드부터 처리하는 방식으로서 각 노드에서 형제 노드를 방문하기 전에 그 자식노드를 먼저 방문하게 된다.
아래는 그래프의 깊이 우선 탐색(DFS)을 표현한 그림이다.
그래프의 시작정점을 A라 했을 때, A는 B,D,E 라는 이웃(자식)노드를 가지고 있는데, 이 중 하나인 B를 방문한 후 B의 형제노드인 D,E를 방문하지 않고 다시 B의 자식노드인 C를 먼저 방문한다.
이렇게 B의 자손을 모두 방문한 후에, B의 형제노드인 D를 방문하고, 계속 이러한 방식으로 나머지 노드들을 방문한다.

*이미지 참조

너비 우선 탐색

너비 우선 탐색(Breath First Search, BFS)은 자신과 가까운 형제 노드부터 처리하는 방식으로서 각 노드에서 자식 노드를 방문하기 전에 형제노드를 먼저 방문하게 된다.
아래는 그래프의 너비 우선 탐색(BFS)을 표현한 그림이다.
그래프의 시작정점을 A라 했을 때, A는 B,D,E 라는 이웃(자식)를 가지고 있는데, 이 중 하나인 B를 방문한 후 B의 형제노드인 D, E를 먼저 방문한다.
다음 B의 자식인 C를 방문하고, E의 자식인 F를 방문한 뒤 F의 형제노드 G를 방문한다.

*이미지 참조

그래프의 특수한 한 형태가 트리(Tree)라고 했을 때, 이진트리의 준위순회(Preorder Traversal), 중위순회(Inorder Traversal), 후위순회(Postorder Traversal)는 너비 우선 순회(Breath First Traversal)에 속하게 된다.
깊이 우선 탐색(DFS)는 엄격한 의미에서는 그래프의 모든 정점을 방문하면서 목표 노드를 검색하는 연산이라면, 깊이 우선 순회(Depth First Traversal)는 이진 트리에서 모든 정점을 방문하는 연산으로 그 차이가 있지만, 흔히 그 유사성 때문에 이 둘을 혼용해서 사용하는 경우가 많다.
또한, DFS는 루트-왼쪽자식-오른쪽자식 등과 같은 특정한 순서를 정하지 않는 넓은 의미의 개념이지만, 그 구현에 있어 전위순회(Preorder Traversal) 방식의 순서를 따르는 경우가 많기 때문에 일부에서는 전위순회와 혼용해서 사용하기도 한다.

깊이 우선 탐색(DFS) 구현

깊이 우선 탐색은 크게 재귀호출을 사용하는 방법과 스택을 사용하는 비재귀호출 방식으로 구현하는 방법이 있다.

그래프의 탐색이 트리의 순회와 특히 다른 점은 그래프의 간선은 트리와 달리 부모-자식 간의 링크 뿐만 아니라 여러 정점들이 무차별적으로 연결될 수 있다는 점이다.
따라서, 그래프의 탐색은 해당 정점을 이미 방문했는지를 체크하는 추가적인 작업이 포함되어야 한다.
정점을 이미 방문했는지 체크하기 위해서는 보통 별도의 테이블을 만들어 방문 노드들을 추가하여 관리하거나 노드(Node) 클래스에 방문 여부를 표시하는 속성을 추가하여 이 속성을 사용하는 방법 등이 있다.
깊이 우선 탐색을 재귀호출로 구현하는 일반적인 방식은 전위순회와 유사한 방식으로 먼저 시작 노드를 방문하고, 그 노드의 인접 노드들 각각에 대해 순차적으로 재귀호출을 수행한다.
단, 그래프의 DFS는 노드를 방문할 때 해당 노드를 방문테이블(visited)에 추가하여 그 노드를 이미 방문했음을 표시하고, 나중에 인접 노드들에 대해 재귀호출을 수행할 때 이미 방문하지 않은 노드만 재귀호출을 수행한다.

아래는 깊이 우선 탐색을 재귀호출로 구현한 예제로서, 앞에서(12.3 그래프의 표현) 소개한 Graph<T> 클래스 안에 DFS() 메서드를 구현한 것이다.
아래 예제에서 DFSRecursive() 메서드가 실제 그래프를 재귀호출로 탐색하는 코드인데, 기본적인 로직은 입력 파라미터로 전달된 노드를 방문하고, 그 노드의 인접 이웃 노드들 중 이미 방문하지 않은 노드들에 대해서 DFSRecursive() 메서드를 다시 재귀호출하는 것이다.

*Graph.Example.Example5() 참조

위 예제에서 사용한 테스트용 그래프는 아래와 같이 2개의 부분 그래프를 갖는 그래프이다.

*이미지 참조

위 예제의 DFS() 메서드는 DSFRecursive() 메서드를 호출하는 메서드인데, DFS() 메서드의 주요 역할은 비연결 그래프가 있는 경우 이들을 모두 포함하여 탐색하도록 하는 기능이다.
연결 그래프의 경우 모든 정점이 연결되어 있으므로 임의의 시작 정점에서 DFSRecursive() 메서드를 한번만 호출하면 되지만, 비연결 그래프의 경우는 임의의 시작 정점에서 한번만 DFSRecursive() 메서드를 호출하면 연결되지 않은 부분 그래프는 탐색되지 않기 때문에, 모든 정점들에 대해 루프를 돌며 방문하지 않은 정점으로부터 다시 DFSRecursive() 메서드를 호출하는 것이다.

깊이 우선 탐색(DFS)를 수행하는 다른 방식으로 비재귀호출(Iterative) 방식으로 스택을 사용하는 방식이 있다.
이 방식의 기본적인 로직은 입력 파라미터로 전달된 시작 노드를 Stack에 넣고, 루프를 돌며 Stack에서 노드를 하나씩 꺼내 방문하면서 그 노드의 인접 노드들 중 이미 방문하지 않은 노드들을 Stack 에 넣는 것이다.
루프는 Stack이 비게 될 때까지 계속 동일한 로직을 수행하게 된다.

아래 예제는 스택을 사용하여 DFS를 수행하는 예이다.
한가지 주목할 점은 이번 예제의 DFS 수행 결과는 A E G F D B C X Y 로서 앞의 재귀호출 방식의 수행 결과 A B C D E F G X Y 와 다른데, 이는 인접 노드들을 스택에 넣는 순서가 서로 다르기 때문이다.
그래프에서 인접 노드들을 방문하는 순서가 특별히 정해져 있는 것이 아니게 때문에 DFS 결과는 여러 가지 루트로 출력될 수 있으므로 이 두가지 결과는 맞는 결과이다.
만약 DFS 수행결과를 재귀호출 방식과 동일하게 하기 위해서는 아래 예제의 포현(A) 대신 포현(B)를 사용하면 된다.

*Graph.Node1<T>.cs DFSUsingStack() 참조

너비 우선 탐색(BFS) 구현

너비 우선 탐색은 트리의 레벨 순서 순회와 유사하게 각 레벨에 있는 인접 노드들을 순차적으로 큐에 넣은 후 이 큐에서 노드를 꺼내 레벨 순서대로 노드를 방문하도록 구현한다.
너비 우선 탐색 역시 DFS와 같이 방문한 노드를 체크하는 방문테이블(visited)을 관리하면서 이미 방문하지 않은 ㄴ노드만 출력하도록 한다.

아래는 너비 우선 탐색(BFS)을 구현한 예제로서, 앞의 Graph<T> 클래스 안에 BFS() 메서드를 구현한 것이다.
아래 예제에서 private BFS(node, visited) 메서드가 실제 그래프를 탐색하는 코드인데, 기본적인 로직은 입력 파라미터로 전달된 시작 노드를 큐에 넣고, 루프를 돌며 큐에서 노드를 하나씩 꺼내 방문하면서 그 노드의 인접 노드들 중 이미 방문하지 않은 노드들을 큐에 넣는 것이다.
루프는 큐가 비게 될 때까지 계속 동일한 로직을 수행하게 된다.
너비 우선 탐색은 이렇게 큐를 통해 인접노드들 즉 형제노드들을 먼저 방문하게 된다.

*Graph.Node1<T>.cs BFS() 참조

위 예제의 public BFs() 메서드는 private BFS(node, visited) 메서드를 호출하는 메서드인데, BFS() 메서드의 주요 역할은, 앞에서 설명한 DFS()와 같이, 비연결 그래프가 있는 경우 이들을 모두 포함하여 탐색하도록 하는 기능이다.