12.5 그래프의 몇가지 알고리즘

지금까지 그래프의 기초 개념 및 구현에 대해 알아 보았다.
여기서는 그래프를 사용하면서 유용하게 사용되는 몇가지 알고리즘을 소개한다.

위상 정렬(Topological Sort)

위상 정렬이란 그래프의 정점들을 전후 관계를 따져 순서대로 정렬하는 것으로서, 방향성 간선을 가지면서 사이클이 없는 방향 비순환 그래프(Directed Acyclic Graph, DAG)에서만 위상정렬을 사용할 수 있다.

아래 그래프는 A부터 F까지의 정점을 갖는 DAG 그래프이다.
방향성 간선은 정점 간의 앞뒤 관계를 표현하는 것으로, 예를 들어 A -> B 가 의미하는 것은 A가 B보다 먼저 수행되어야 하는 것이도, B 는 A 다음으로 수행되어야 한다는 것을 의미한다.

*이미지 참조

위상 정렬은 업무의 일정을 일어나야 할 순서에 따라 배치해야 하는 곳에 주로 활용되는데, 전후 관계나 의존 관계를 따져 정렬해야 하는 곳에 사용된다.
예를 들어, 일정 스케줄 프로젝트 관리, 선수 과목을 순차적으로 표시한 학교 수강 코스, 작업 공정 순서에 따라 그려진 작업 공정표 등에 응용될 수 있다.

위상 정렬을 구현하는 방식은 크게 깊이 우선 탐색(DFS)을 변형해서 구현하는 방법과 진입차수를 이용하는 방법이 있는데, 여기서는 DFS를 사용하는 방법에 대해 알아보자.

DFS는 시작 노드(A)에서 출발하여 먼저 그 노드(A)를 출력한 후 그 인접노드들에 대해 차례로 DFS를 재귀호출하게 된다.
하지만, 위상 정렬은 시작 노드(A)에서 출발하여 먼저 그 인접노드들에 대해 차례로 재귀호출한 후 노드를 역순으로 저장한다.
위상 정렬에서는 가장 깊이 있는  곳의 오드(F)를 마지막에 저장하고, 마지막 노드의 직전 노드(D)를 그 노드(F) 바로 앞에 저장한다.
이를 위해 결과 거장 장소로 스택을 사용하몀ㄴ 자연스럽게 역순으로 저장될 것이고, 만약 연결리스트를 사용한다면 AddFirst()를 사용하여 앞쪽에 추가하는 방식을 사용하면 된다.
아래 예제는 재귀호출을 사용하여 위상정렬을 수행하는 핵심 부분을 발췌한 것이다.

*Graph.Node1<T>.cs TopoSort() 참조

위상정렬을 수행할 때 임의의 정점 하나에 대해서 위상정렬을 수행하면 그래프의 일부에 대해서만 위상정렬이  수행되므로 모든 정점에 대해 루프를 돌면서 이미 방문하지 않는 노드들에 대해 위상정렬을 수행하는 방식을 사용한다.
위상정렬은 일반적으로 하나의 DAG 그래프에 대해 하나 이상의 위상정렬 결과를 가질 수 있다.

아래는 지금까지 설명한 번형된 DFS 방식으로 위상정렬을 구현한 예제이다.
테스트 코드에서는 위 그림에서 사용된 그래프에 대해 위상정렬을 수행하였다.

*Graph.Node1<T>.cs TopologicalSort() 참조

최소 신장트리(Minimum Spanning Tree, MST)

그래프에 있는 모든 정점을 사이클 없이 연결한 트리를 신장트리라 한다.
신장트리는 그래프의 최소 연결부분그래프로서, n 개의 정점을 갖는그래프에서 모든 정점을 연결하는 최소 간선의 수는 n-1 이 되고, 이렇게 연결된 트리가 신장트리이다.
여기서 말하는 트리는 우리가 일반적으로 말하틑 루트가 있는 트리(Rooted Tree)라기 보다는 특별히 루트를 갖지 않는 비사이클 무방향 연결 그래프를 일컫는다.

하나의 그래프에 대해 보통 여러 개의 신장트리가 있을 수 있는데, 그래프를 깊이 우선 탐색(DFS)하거나 너비 우선 탐색(BFS)하여 신장트리를 구하게 된다.

최소 신장트리는 최소 비용 신장트리 (Minimum Cost Spanning Tree)라고도 불리우는데, 신장트리 중 가중치의 합이 최소인 신장트리를 말한다.
최소 신장트리는 도로망이나 케이블망 등에서 최소 비용으로 망을 구성하는데 흔히 활용된다.

아래 그림은 최소 신장트리의 한 예를 표현한 것으로, 굵은 선으로 표시된 C-A-B-D-E 와 D-F 로 연결된 부분이 그래프의 최소 신장트리가 되고, 최소 비용은 13이 된다.

*이미지 참조

최소 신장트리를 구하는 알고리즘으로 가장 잘 알려진 것은 Kruskal의 알고리즘과 Prim의 알고리즘으로 이 둘은 모두 탐욕 알고리즘(Greedy Algorithm)에 기반한 알고리즘이다.

Kruskal 알고리즘

Kruskal의 알고리즘은 간선을 가중치순으로 소트한 후, 가중치가 가장 낮은 간선부터 사이클에 형셩되지 않는 한 차례로 선택해 나가는 알고리즘이다.
Kruskal 알고리즘에서 사이클을 체크하기 위해서 분리집합(Disjoint Set)이나 DFS 방식을 사용할 수 있는데, 여기서는 흔히 사용되는 분리집합을 이용하여 알고리즘을 구현하도록 한다.

분리집합(Disjoint Set)이란 서로 분리되어 있는 집합들을 가리키는 것으로 분리되어 있으므로 집합들 사이에 교집합이 존재하지 않는다.
분리집합은 흔히 집합 요소를 분류하는데 사용되는데, Kruskal 알고리즘에서는 두 요소가 동일 집합에 있으면 요소들이 서로 연결되어 있는 것으로 판단하며, 다른 집합에 있으면 두 요소는 연결되어 있지 않다고 판단한다.

분리집합은 아래 그림과 같이 각 집합 요소가 부모를 가리키는 구조를 가지고 있으며, 가장 상위에 있는 부모로 집합을 구분하게 된다.

즉, 분리집ㅈ합에서 각 집합의 요소들은 모두 최상위 부모와 연결되어 있는데, 어떤 두 요소가 그 집합에 속하는지를 체크하기 위해서는 그 두 요소의 최상위 부모가 서로 같은지를 체크하면 된다.
분리집합은 Find()와 Union() 연산을 기본 연산으로 갖는데, Find()는 파라미터로 들어온 요소의 최상위 부모를 찾는데 사용되며, Union()은 두 분리집합을 병합하여 하나의 집합으로 만드는데 사용된다.
분리집합의 병합은 한 집합의 최상위 부모를 다른 집합의 자식으로 연결시키면 된다.

*이미지 참조

아래는 분리집합을 구현한 예제로서 해시테이블을 사용하여 요소와 그 부모를 Key~Value로 저장하면서 분리집합의 Find()와 Union() 연산을 간단하게 구현한 것이다.

*Graph.DisjointSet.cs 참조

Kruskal 알고리즘은 다음과 같은 절차를 따른다.

	1. 최소 신장트리(MST) 결과 집합을 초기화한다.

	2. 그래프의 모든 정점들에 대해 각 정점당 하나의 분리집합(Disjoint Set)을 생성한다.
	   즉, 정점이 N개이면 N개의 분리 집합을 생성한다.
	   서로 다른 분리집합에 있다는 것은 서로 연결되어 있지 않다는 것을 의미한다.

    3. 그래프의 모든 간선들을 가중치를 기준으로 오름차순으로 정렬한다.
	   이를 통해 아래 스탭4에서 가중치가 낮은 것부터 처리하게 된다.

    4. 스탭3에서 정렬된 모든 간선들을 루프를 돌며 하나씩 처리하는데,
		- 간선들의 시작정점(from)과 목표정점(to)이 각각 속해 있는 분리집합을 구한다.
		  이는 Find(from)과 Find(to)를 통해 구하는 것으로 해당 분리집합의 최상위 부모를 찾는 것이다.
		  만약 시작정점(from)과 목표정점(to)의 최상위 부모가 같으면 둘은 동일 분리집합에 속하는 것이고 서로 연결되어 있다는 것을 의미한다.
	    - 만약 두 분리집합이 같지 않으면 서로 연결되어 있지 않은 것이므로 서로 연결하기 위해 두 분리집합을 병합하고, 결과 집합에 새로 연결된 해당 간선을 추가한다.
		  이렇게 하면, 가중치가 낮은 순으로 새로 연결한 간선을 MST 결과 집합에 추가하게 된다.

	5. MST 결과 집합을 리턴한다.
	
*Graph.Example.cs Example7() 참조

Prim 알고리즘

최소 신장트리를 구하는 또 다른 알고리즘으로 Prim 알고리즘이 있다.
Prim 알고리즘은 현재의 정점 혹은 정점집합에 인접해 있는 간선들 중 가장 낮은 가중치를 갖는 간선을 계속 선택해 나가는 방식이다.
즉, 임의의 시작정점을 선택하고 그 정점에 연결된 인접 간선들 중 가중치가 최소인 간선을 선택하고 그 간선으로 연결된 정점을 최소신장트리에 포함시킨다.
이어 최소신장트리 정점들 주위에 연결되어 있는 인접 간선들에 대해 같은 방법을 반복하면서 새 간선을 선택하는데, 이러한 방식으로 모든 정점들이 신장트리에 포함될 때까지 간선 선택 과정을 반복한다.

좀 더 정형화하면 Prim 알고리즘은 다음과 같은 절차를 따른다.

	1. 최소 신장트리(MST) 결과 집합을 초기화한다.

	2. 그래프에서 임의의 시작정점을 정하고, 이를 방문노드집합(visted)에 넣는다.

	3. 모든 노드를 방문할 때까지(즉, 모든 노드를 방문노드집합에 넣을 때까지) 루프를 돌며 아래 사항을 처리한다.
		- 방문노드집합에 인접한 간선들 중에 가중치가 가장 낮은 간선을 찾는다.
		  즉, 방문노드집합에 복수 개의 정점들이 있을 때, 이들 정점들과 외부의 정점들 사이의 인접 간선들 중에서 최소 가중치 간선을 선택한다.
		- 해당 간선을 MST 결과 집합에 넣고, 간선에 연결된 새 노드를 방문노드집합에 추가한다.

	4. 결과 집합을 리턴한다.

Prim 알고리즘에서 가중치가 가장 낮은 간선을 찾을 때, 각 정점에 모든 간선들을 하나씩 체크하는 방식이 있는데 이는 직관적이지만 덜 효율적인 방법이다.
좀 더 효율적으로 최소 가중치 간선을 찾기 위해서는 최소힙(Min Heap)과 같은 우선순위큐(Priority Queue)를 사용하여 구현할 수 있다.

아래는 Prim 알고리즘의 개념을 설명하기 위한 예제이다.
여기서는 좀 더 직관적으로 예시하기 위해 정점의 간선들을 하나씩 체크하는 방식을 사용하였는데, 좀 더 효율적인 코드를 위해서는 예제의 여러 부분을 최적화할 필요가 있다.

*Graph.Example.cs Example8() 참조

최단경로 (Shortest Path) 알고리즘

그래프의 한 정점에서 다른 목표정점까지 도착하는데 가장 빠른 경로를 구하는 문제를 최단경로 문제라한다.
예를 들어, GPS에서 서울에서 부산까지 가장 빠른 경로를 찾거나 지하철에서 시청에서 강남역까지 가는 가장 빠른 경로를 찾고 싶을 때 최단경로 알고리즘을 사용할 수 있다.
이러한 최단경로를 구하는 방법으로 가장 잘 알려진 것은 다익스트라(Dijkstra) 알고리즘이다.

다익스트라 알고리즘은 한 시작정점에서 모든 정점들까지의 최단경로를 찾아구는 알고리즘으로서 이 알고리즘의 기본 로직은 시작정점에서 출발하여 인접 정점들을 추가해 가면서 최단거리를 갱신하는 것이다.
즉, 시작정점에서 출발하여 인접간선들에 연결된 인접 정점들에 이르는 최단 거리를 갱신하고, 인접 정점 중 최단거리를 갖는 정점을 선택해 방문노드집합에 추가하고, 다시 이 방문노드집합의 인접 노드들에 대해 동일한 방식으로 최단 거리를 갱신한다.

다익스트라 알고리즘은 다음과 같은 절차를 따른다.
아래 절차를 보면 알 수 있듯이, 다익스트라 알고리즘은 앞의 Prim 알고리즘과 유사한 로직을 가지고 있다.

	1. 시작정점에서 각 정점에 이르는 최단거리를 저장하는 테이블을 생성한다.
	   테이블은 (1)정점 간 최단거리(totalCosts)와 (2)목표정점에 이르는 경로 중 바로 직전 정점(prevNodes)을 저장한다.
	   초기에는 모든 정점간 최단거리를 무한대(아래 예제에선 int.MaxValue)로 설정한다.

    2. 시작정점의 최단거리를 0 으로 설정하고 그 직전 정점은 자신 즉 시장정점으로 설정한다.(시작정점으로부터 시작정점까지의 거리는 0 이다.)

	3. 방문노드집합(visited)에 시작정점을 추가한다.

	4. 모든 노드를 방문할 때까지 (즉, 모든 노드를 방문노드집합에 넣을 때까지) 루프를 돌며 아래 사항을 처리한다.
		- 방문노드집합(visited)에 인접한 간선들에 대해 새 경로에 대한 가중치를 다시 계산한다.
		  인접 간선에 대한 경로 가중치가 기존 최단거리 테이블(totalCosts)에 있는 가중치보다 작은 경우 값을 갱신한다.
	    - 인접 간선들에 연결된 노드들 중 최소거리를 갖는 노드를 선택하여 방문노드집합(visited)에 추가하고 다시 루프를 돈다.

아래 예제는 Dijkstra 알고리즘의 개념을 설명하기 위한 코드로서, 위의 Prim 예제에서 사용한 GraphV3 클래스 안에서 구현한 메서드이다.
여기서는 단순하게 예시하기 위해 인접 간선 배열을 일일이 방문하는 방식을 사용하였는데, 우선순위 큐를 사용하면 보다 효울적으로 구현할 수 있다.

*Graph.Example.cs Example9() 참조