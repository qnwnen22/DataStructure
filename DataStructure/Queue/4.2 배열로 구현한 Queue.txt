4.2 배열로 구현한 Queue

고정 배열을 사용한 Queue구현

배열을 사용하며 Queue를 구현하기 가장 단순한 구현은 고정된 배열을 할당하고 Front나 Rear 인덱스를 관리하면서 큐를 구현하는 방식이다.
배열에 새 데이타를 추가할 때는 Rear 인덱스가 가리키는 배열요소에 데이타를 넣고, 데이타를 읽으며 제거할 때는 Front 인덱스가 있는 배열요소를 제거한다.

Front에서 배열요소를 제거할 때는 Front 인덱스를 Front 다음 요소로 이동하는 방식을 사용하거나 또는 모든 배열요소를 Front 앞으로 땡겨 옮기는 방식을 사용할 수 있다.

첫번째 방식은 Rear 인덱스가 고정 배열 크기만큼 이동하면 더 이상 큐에 데이타를 넣을 수 없으며, Front 인덱스가 계속 이동하여 최대 고정 배열 크기만큼만 이동할 수 있다.
즉, 큐에 저장할 수 있는 최대 데이타수가 배열 크기와 같게 된다.

두번째 방식, 즉 Front가 제거될 때마다 배열요소를 모두 앞으로 땡기는 방식은 제거된 요소들만큼 계속 데이타를 넣을 수 있는 장점이 있지만 Queue에서 데이타를 꺼낼 때마다 배열요소들을 모두 옮겨야 하기 때문에 성능면에서 좋지 않은 방식이다.

고정 배열로 큐를 구현할 때 발생하는 이러한 문제들은 아래 소개하는 원형 배열을 이용함으로써 해결될 수 있다.


원형 배열을 사용한 큐 구현

배열을 사용하여 Queue를 구현할 때 고정배열이 갖는 문제점들을 해결하기 위해 흔히 원형 배열을 사용한다.
고정된 크기의 배열에서 Front 인덱스가 가리키는 요소를 읽고 인덱스를 계속 다음 요소로 이동해 가면 금새 마지막 배열요소에 다다르게 되고 더이상 데이타를 추가할 수 없게 된다.
즉 Front 인덱스가 마지막 요소에 이르렀을 때 데이타를 추가할 수 있는 공간은 앞에 모두 비어 있는데도 실제 데이타를 추가할 수 없게 되는 것이다.
이러한 문제점을 해결하기 위해 원형 배열을 사용할 수 있다.
즉, 마지막 배열 요소에서 첫 요소로 이동할 수 있는 원형 배열을 사용하면 비어 있는 공간을 효율적으로 재사용할 수 있는 Queue를 구현할 수 있다.
물론 원형 배열이라도 모든 요소가 차게 된다면 더이상 큐에 데이타를 넣을 수 없게 되는데, 이를 위해 원형 배열을 동적으로 확장 하는 원형 동적 배열의 구현을 생각해 볼 수 있다.

Queue를 구현하는 원형 배열은 데이타를 읽기 위한 포인터로서 Front 배열 인덱스를 가지며, 데이타를 추가하기 위한 포인터로서 Rear 인덱스를 갖는다.

예를 들어, 아래 그림에서 A[1]이 Queue 데이타를 읽는 시작점이므로 Front 인덱스는 1이되고, A[4]는 큐 마지막 요소를 가리키며 그 다음 요소에 새 데이타를 추가할 수 있게 하는 Rear 인덱스는 4가 된다.
(주: Rear 인덱스는 Queue 구현 방법에 따라 큐의 마지막 요소를 가리키거나 혹은 마지막 요소의 다음 요소 즉 새 데이타가 추가 되는 위치를 가리킬 수 있다.)

					원형배열 QUEUE

 	 A[0]  A[1]  A[2]  A[3]  A[4]  A[5]  A[6]  A[7]
	[    ][ 11 ][ 12 ][ 13 ][ 14 ][    ][    ][    ]


				A[7]		A[0]
				 □			 □  		  Front=1 
										↙ (Rear)
		A[6] □					 11 A[1]


		A[5] □					 12 A[2]

				 14          13	
				A[4]		A[3]
			  ↗
		  Rear=4
		 (Write) 

	
원형배열은 배열을 순환하는 구조로 만들어야 하므로, Front/Rear를 위한 배열 인덱스를 증가시킬 때 mod연산자를 사용하여 배열의 마지막에 도착했을 때 첫 배열 인덱스를 돌아오게 한다.

C#에서 mod 연산자는 % 로서 나머지를 구할 때 사용되는데, 예를 들어 10 % 8 은 10을 8로 나눈 나머지 즉 2가 된다.
이렇게 mod 연산자를 사용하여 Front(혹은 Rear) 포인터의 증가를 표현하면 다음과 같이 표현할 수 있다.

	Front = (Front + 1) % A.Length;
	
위 표현식을 사용하여, A[7] 요소를 읽고 다음 요소로 Front 포인터를 이동한다면, (7 + 1) % 8 = 0 즉 배열 0번 요소로 이동하게 된다.

큐를 구현하는 기본 과정을 살펴보면 다음과 같다.

	1. Queue의 초기 상태에서 Front와 Rear 인덱스는 -1 로 설정한다

	2. Queue에 데이타를 처음 추가할 때, A[0]에 넣고 Front와 Rear는 0이 된다.

	3. Queue에 데이타를 추가(Enqueue)할 때, Queue가 가득 찬 상태인지 체크하고, 가득 차지 않았으면 다음 위치 즉(Rear + 1) % A.Length 위치로 이동하여 데이타를 넣는다.
	   가득 찬 경우(a) 에러를 발생시키거나, (b) 배열을 확장하여 데이타를 추가할 수 있게 한다.
	   Queue가 가득 찬 상태인지를 체크하는 방법은 Rear의 다음 인덱스가 Front와 같은지 체크하면 되는데, 식으로는(Rear + 1) % A.Length == Front 와 같이 표현할 수 있다.

    4. Queue에서 데이타를 읽어 제거(Dequeue)할 때는, 먼저 큐가 비어 있는지 체크하고, 비어 있지 않으면 데이타를 읽고 Front를 하나 증가시킨다.
	   Front의 증가는 식으로 Front = (Front + 1) % A.Length 와 같이 표현할 수 있다.
	   Queue에서 마지막 요소를 읽어 낼 때, 즉 Front와 Rear가 같을 때, 데이타를 읽어낸 후 Front와 Rear를 -1로 표시한다.
	   이는 초기 상태의 Front와 Rear가 -1이었던 것과 같은 상태인데, Queue가 비어 있다는 것을 의미하며, 여기서 -1은 Empty를 표현하는 특별한 값으로 볼 수 있다.
	   위와 같은 구현에서 Queue가 비어 있는지 체크하는 방법은 Front와 Rear가 모두 -1 인지를 체크하면 된다.
	   
아래 예제는 원형배열을 사용하기 간단한 Queue를 구현한 것으로 여기서는 배열을 확장하는 기능을 추가하지 않았다.
배열을 확장하는 기능을 추가하기 위해서는 Enqueue() 메서드에서 큐가 가득 찼을 때, 배열을 확장한 후 기존 배열 데이타를 확장된 배열로 이전하면 된다.

*Queue.QueueUsingCircularArray.cs 및 Enqueue(), Dequeue() 메서드 참조

Queue의 가장 기본적인 메서드는 데이타를 추가하는 Enqueue()와 데이타를 읽어 내는 Dequeue()이다.
Enqueue()의 경우 데이타를 추가하기 전에 Queue가 가득 차 있는지 체크하고, Dequeue()의 경우 데이타를 읽기 전에 큐가 비어 있는지를 체크해야 한다.


원형 배열 큐와 다른 방식의 구현

위와는 좀 다른 구현 방법으로 Rear를 새 데이타가 삽입되는 위치로 설정하고, Rear의 다음 위치가 Front와 같으면 데이타를 추가하지 않고 큐가 가득 찬 상태(Full)로 정의하는 방식이 있다.
그림으로 나타내면 아래와 같이 표현할 수 있다.
위 방식과 다른 점은 Rear 포인터가 이미 추가된 배열요소의 마지막에 있는 것이 아니라 마지막 요소 바로 다음 인덱스를 가리키고 있다는 점이다.

				A[7]		A[0]
				 □			 □  		  Front=1 
										↙ (Rear)
		A[6] □					 11 A[1]


		A[5] □					 12 A[2]
		↗
	Rear=4		 14          13	
	(Write) 	A[4]		A[3]
			  

이 방식은 전체 배열에서 1개를 뺀 숫자만큼만 데이타를 넣을 수 있는 단점이 있지만, Front와 Rear가 같으면 큐가 Empty 상태임을 쉽게 정의할 수 있는 장점이 있다.
즉, 앞에서와 같이 -1이라는 특별한 값을 사용할 필요가 없다.
배열에 추가할 공간이 1개 남았을 때, 즉 Rear의 다음 위치가 Front와 같을 때, 데이타를 채우고 Rear+1 으로 이동하게 되면 Front와 Rear가 같게 되는데, 그러면 Queue가 Empty인지 Full인지 구별할 수 없게 된다.
따라서, Rear의 다음 위치가 Front와 같으면 데이타를 추가하지 않고 Full 이라고 정의하는 것이다.

아래 그림은 Queue가 가득 찬 상태를 표현한 것으로 Queue가 가득찼을 때 Rear 다음 위치가 Front와 같게 된다.

			QUEUE가 가득찬 상태 (Full)
		조건식:(rear + 1) % size = front

								Rear=0
								↙
				A[7]		A[0]
				 17			 □  		  Front=1 
										↙ 
		A[6] 16					 11 A[1]


		A[5] 15					 12 A[2]
		
	    		 14          13	
	        	A[4]		A[3]

또한, 아래 그림은 Queue가 빈 상태를 표현한 것으로 Queue에 데이타가 1개 남았을 때 Dequeue를 하면 Front 인덱스와 Rear 인덱스가 같게 되어 Empty 상태가 된다.


								QUEUE가 빈 상태 (Empty)
								조건식 : front == rear
				

			 □         □  	  Front=1				 □         □
								↙
		□					 11 					□					 □ 
											=>								  Front=2		
																			↙
		□					 □ 					□					 □ 
								↖				   							↖
    		 □         □	      Rear=2				 □         □	      Rear=2
        	

아래 예제를 이러한 방식으로 구현한 샘플 코드이다.

*Queue.QueueUsingCircularArray2.cs 및 Enqueue(), Dequeue() 메서드 참조

배열을 사용하여 Queue를 구현하는 또 다른 접근 방법으로 count라는 필드를 두고 Enqueue와 Dequeue 시에 count를 증감하는 방법이 있다.
이 방식은 Queue가 가득 찬 상태와 빈 상태를 쉽게 체크할 수 있으며 또한 현재 Queue에 들어 있는 데이타 수를 쉽게 알 수 있다는 장점이 있다.
만약 count가 0 이면 Queue가 빈 상태를 의미하며, count가 Queue의 크기와 동일하다면 Queue가 가득 찬 상태라는 것을 알 수 있다.
아래 예제를 이러한 방식을 구현한 코드이다.

*Queue.QueueUsingCircularArray3.cs 및 Enqueue(), Dequeue() 메서드 참조