2.3 동적 배열(Dynamic Array)

배열은 일정한 크기의 연속된 배열요소들의 집합이고, 배열의 크기는 초기화시 미리 지정된다.
정적 배열(Static Array)은 이렇게 처음에 지정한 고정 크기를 그대로 계속 유지하는 배열이다.
C#에서 기본적으로 사용하는 배열 문법, 즉 int[], string[,] 같은 식으로 선언된 배열들은 모두 정적 배열에 해당한다.

하지만 배열의 최대 크기를 미리 알 수 없는 경우도 있으며, 필요시 배열을 중간에 확장해야 하는 경우도 있다.
이렇게 배열이 꽉 찼을 경우 배열을 확장하거나 반대로 배열이 너무 적은 요소를 갖을 경우 축소하는 기능을 갖는 배열을 동적 배열(Dynamic Array)이라 한다.

동적 배열을 만드는 가장 간단한 방식은 새로운 요소가 추가될 때마다 배열 크기를 하나씩 늘려나가는 것이다.
즉, 아래 예제와 같이 새 배열요소를 추가할 때 기존 배열(arr)의 크기보다 1개 더 큰 임시 배열(temp)을 생성하고, 임시 배열에 모든 요소를 복사한 후, 다시 임시 배열(temp)을 기존 배열(arr)에 할당하고, 배열 마지막 요소에 새 배열요소를 추가하는 것이다.

*Array.DynamicArray1.cs 참조

위와 같은 방식은 필요할 때마다 배열을 하나씩 동적으로 증가시키는 방식으로 꼭 필요한 공간만을 사용한다는 장점이 있지만, 매번 새로운 배열 공간을 생성하고 여기에 기존 배열요소들을 전부 복사해 넣어야 한다는 단점이 있다.

이러한 방식은 배열에 하나의 요소를 추가할 때마다 전체 기존 배열을 복사해야 하기 때문에, 배열의 크기가 n일 때 O(n)의 시간이 소요된다.
예를 들어, 배열의 크기가 1일때 새 요소를 추가하면 기존 배열 요소 1개를 복사해야 하고, 배열의 크기가 2일 때는 2개를, 3일 때는 3개를 복사해야 한다. 
이러한 방식으로 임의의 배열 크기가 n 일때, n개씩 복사하는 동작(operation)을 수행하여야 한다.

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[참고] 알고리즘의 수행시간을 대략적으로 나타내는 방법을 점근 표기법(Asymptotic Notation)이라고 하는데, 대표적인 점근 표기법에는 O (Big O) 표기법, Ω(Big Omega) 표기법, Θ (Big Theta) 표기법이 있다.
O 표기법은 알고리즘이 최악으로 실행될 경우의 성능을 표현할 때 사용하며, Ω 표기법은 알고리즘이 가장 최선으로 실행될 경우의 성능을 표시한다.
그리고 Θ 표기법은 알고리즘 성능의 상한(O 표기법)과 하한(Ω 표기법)을 동시에 나타내는데 사용한다.
알고리즘의 성능을 표현하는데 가장 많이 상요하는 것은 O 표기법으로 이는 최악의 경우 아무리 늦더라도 이 정도의 성능은 보장한다는 것을 의미한다.
O 표기법은 "O(증가함수)" 와 같이 O 뒤의 괄호 안에 증가함수를 넣는데, 증가함수란 입력 데이타의 크기 n에 대해 알고리즘의 수행시간이 늘어나는 비율을 나타내는 함수이다.

예를 들어, 입력 데이타의 크기 n 에 대해 수행시간이 2n² + 3n + 4 와 같이 같이 걸린다고 했을 때, 이는 O 표기법으로 O(n²)처럼 표시한다.
입력 데이타의 크기 n이 계속 크게 증가할 때, 수행시간 수식에서 가장 큰 영향을 미치는 것은 최고차항이며, 하위차항이나 각 항의 계수는 영향이 미비해 지게 된다.
알고리즘의 성능은 보통 데이타 크기가 작을 경우는 의미가 없고 데이타 크기가 크게 증가했을 때 큰 의미가 있으므로, O 표기법을 사용하여 대략적인 성능을 표시할 때 최고차항과 같이 핵심적인 증가 비율을 사용하게 된다.

O 표기법으로 자주 사용되는 표현은 O(1), O(log n), O(n log n), O(n²), O(n³),  O(2ⁿ) 등인데, 가장 성능이 좋은 O(1) 부터 점차적으로 낮은 성능을 표시한 것 이다.
O(1)은 입력 데이타의 수가 아무리 많아지더라도 알고리즘 수행시간이 일정한 상수 시간에 완료된다는 것을 의미하는 것으로 예를들어 1000개의 데이타가 있던 천만 개의 데이타가 있던 테이타수와 상관없이 수행시간이 비슷하게 완료되는 것을 의미한다.
또 다른 예로 O(n)은 입력 데이타의 수와 동일한 비율로 수행시간이 증가한다는 것이고, O(n²)은 입력 데이타 크기 n 에 대해 그 수의 제곱만큼의 수행시간이 더 걸린다는 것을 의미한다.
마지막으로 점근 표기법은 수행시간 뿐만 아니라 알고리즘에 소요되는 메모리 공간을 대략적으로 나타내기 위해서 사용될 수도 있다.
즉, 알고리즘이 실행되는 수행시간은 시간 복잡도(Time Complexity)로 나타내고 그에 소요되는 공간은 공간 복잡도(Space Complexity)로 나타내는데, 이들은 점근 표기봅으로 주로 Big O 표기법을 사용하여 표현한다.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

위와 같은 단점을 해결하기 위해 흔히 사용되는 동적 배열의 구현 방식은 배열을 2배씩 확장하는 것이다. 
즉, 배열 확장이 필요한 경우 배열 크기가 2배인 새로운 임시 배열을 생성하고 모든 기존 배열 요소들을 새 임시 배열에 복사한 뒤 기존 배열을 해제하는 방식이다.
아래는 이러한 방식으로 구현한 동적 배열의 예제이다.

*Array.DynamicArray2.cs 참조

위 예제는 배열의 최대 수용가능 용량(Capacity)과 현재 배열요소 수(Count)를 속성으로 가지고 있으며, Count가 Capacity보다 크거나 같으면 즉 배열이 꽉 차면, 배열을(Growth Factor만큼) 2배로 확장하고 새 배열요소를 추가하고 있다.
동적배열에서 흔히 다루는 주제 중의 하나는 성장인자(Growth Factor)인데, 이는 배열이 꽉 찼을 때, 배열을 얼마만큼 늘려야 하는가를 정하는 인자이다.
성장인자는 각 라이브러리/Framework 마다 다르지만 통상 2배 혹은 1.5배를 많이 사용한다.

위 예제의 경우 처음 배열의 크기는 16이고, 다음 확장시 32, 그 다음 확장시 64 등으로 2배씩 증가한다.
따라서, 배열인덱스 0부터 15까지는 새 요소를 추가할 때 즉시 추가되며, 17번째 요소 추가시 배열크기 32인 새 배열로 확장한 후, 16개의 기존 요소들을 복사하게 된다.
이때, 배열요소 추가수에 따른 수행시간을 그래프로 그리면 아래와 같이 된다.

┎━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃																														┃
┃														수행시간														┃
┃																														┃
┃																														┃
┃	35																													┃
┃																														┃
┃																														┃
┃	30																									|				┃
┃																										|				┃
┃																										|				┃
┃	25																									|				┃
┃																										|				┃
┃																										|				┃
┃	20																									|				┃
┃																										|				┃
┃												  |														|				┃
┃	15											  |														|				┃
┃												  |														|				┃
┃												  |														|				┃
┃	10											  |														|				┃
┃												  |														|				┃
┃												  |														|				┃
┃	5											  |														|				┃
┃												  |														|				┃
┃												  |														|				┃
┃	0	|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  	┃
┃																														┃
┃		1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36		┃
┃																														┃
┕━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┙

위 그래프에서 17번째 요소 추가의 경우, 16개의 요소 복사에 따른 수행시간이 표시되고 있다.
그런데, 이러한 16개의 복사 수행시간을 기존 첫 요소부터 16번 요소까지의 수행시간에 분할하여 분산한다면, O(1) * 2 이 되어 결국 수행시간은 O(1)이 됨을 알 수 있다.
이는 33번째에서의 수행시간에도 동이라게 적용되어 결국 이 동적 배열은 요소 추가시 O(1)의 수행시간을 갖게 됨을 알 수 있다.
참고로, 이렇게 일부 수행에서 일어나는 비싼 수행 비용을 분산시켜 여러 다른 일반 수행들로 분할 상환하여 비용을 계산하는 방식을 분할상환분석(Amortized Analysis)이라 부른다.

이러한 분석을 통해 배열을 하나씩 증가하는 동적 배열 방식(수행시간이 O(n)) 보다 2배 혹은 1.5배로 증가하는 방식(수행시간이 O(1))이 훨씬 효울적임을 알 수 있다.