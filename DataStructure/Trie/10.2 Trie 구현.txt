10.2 Trie 구현

단순한 트라이를 표현하기 위해 먼저 트라이가 소문자 알파뱃만을 처리한다고 가정해보자.
이러한 가정 하에 트라이 노드는 아래와 같이 26개의 알파뱃 링크를 갖는 배열과 단어의 끝을 표시하는 플래그를 갖도록 표현할 수 있다.

*Trie.Node.cs 참조

트라이에서 필요한 주요 메서드로는 새로운 문자열을 트라이에 추가하는 Insert() 메서드와 특정 문자열이 트라이 트리에 존재하는지 검색하는 Find() 메서드를 들 수 있다.

Insert() 메서드의 기본 로직은 문자열의 각 문자에 상응하는 자식노드 링크를 추가하거나 이미 있는 경우 해당 자식노드로 이동하면서 문자열의 마지막 문자에 상응하는 노드에 다다르면 EndOfWord 플래그를 true로 설정하는 것이다.

비슷한 방식으로 Find() 메서드의 기본 로직은 문자열의 각 문자에 상응하는 자식노드 링크를 체크해서 상응 링크가 null이면 false를 리턴하고 문자열의 마지막 문자에 상응하는 노드에 다다르면 EndOfWord 플래그를 리턴하면 된다.
이때 EndOfWord는 false일 수도 있는데, 이는 다른 문자열의 부분 문자열이지만 완전한 문자열로 추가되지 않을 수도 있기 때문이다.

아래 예제는 알파벳 문자열을 저장하는 간단한 Trie 클래스를 표현한 코드이다.
아래 SimpleTrie 클래스는 노드 클래스(Node)를 내부 클래스로 포함하고 있으며, 루트노드를 필드로 가지고 있다.

*Trie.SimpleTrie.cs 참조

위에서 구현한 트라이는 소문자 알파벳이라는 제약 조건을 달았는데, 이는 알파벳은 상대적으로 작은 문자셋을 가지고 있기 때문에 고정배열을 적용해 구현하는 것을 보이기 위함이었다.
만약 문자셋이 유니코드와 같이 전세계 언어를 포함해야 하는 경우나 혹은 한글이나 중국어와 같이 상대적으로 많은 문자셋을 가지는 경우, 고정배열을 사용하는 것보다 해시테이블이나 동적배열을 사용하는 방법을 고려해 볼 수 있다.
특히 해시테이블을 사용하면 유니코드와 같은 광범위한 문자셋에서 대응하는 노드를 쉽게 찾아낼 수 있다.

아래 예제는 유니코드 문자열을 처리하도록 배열 대신 해시테이블을 사용한 Trie, 클래스를 표현한 코드이다.
기본적인 로직은 위 SimpleTrie 클래스와 동일하며, 자식노드를 검색하는 부분을 위치 기반의 배열이 아닌 해시테이블을 사용하고 있다는 점이 차이가 있다.
참고로, C#에서 문자열을 기본적으로 유니코드를 사용한다.

*Trie.Trie.cs 참조