8.4 이진 탐색 트리의 몇가지 알고리즘

이진 탐색 트리를 사용하면서 유용하게 사용되는 몇가지 알고리즘을 소개한다.

K번째 작은 수 혹은 K번째 큰 수 구하기

이진 탐색 트리에서 K번째로 작은 수를 구하는 코드를 생각해 보자.
이진 탐색 트리를 중위 순회하면 정렬된 데이타를 얻을 수 있으므로, 이를 배열에 담고 K번째로 작은 배열 요소를 찾으면 쉽게 문제를 해결할 수 있다.
그러나, 이렇게 추가적인 배열을 사용하지 않고도 문제를 해결할 수도 있다.
즉, 트리를 순회해 나가면서 K번째 작운 수를 구할 수도 있다.
아래 예제는 순회와 동시에 K번째 작은 수를 찾는 방식으로 count변수를 전달하여 현재 노드가 순위상 몇 번째 노드인지를 함께 체크하고 있다.

*BinarySearchTree.BST.cs FindKthSmallest()메서드 참조

위와 비슷한 방식으로 K번째 큰 수를 구할 수도 있는데, 차이점은 위의 중위 순회가 왼쪽 - 루트 - 오른쪽 순으로 이동하였다면, K번째 큰 수는 반대로 오른쪽 - 루트 - 왼쪽 순으로 이동하면 내림차순으로 노드를 순회할 수 있게 된다.
아래는 순회와 동시에 K번째 큰 수를 찾는 예제이다.

*BinarySearchTree.BST.cs FindKthLargest()메서드 참조

중위 순회에서 특정 노드의 다음 노드 찾기

이진 탐색 트리를 중위 순회할 때 어느 한 노드 바로 다음에 오는 노드(Successor)를 찾아 보도록 하자.
중위 순회에서 임의의 노드 X의 다음 노드는 (1) X의 오른쪽 자식 노드가 없을 경우 X의 부모 노드가 되고, (2) X의 오른쪽 서브트리가 있을 경우 오른쪽 서브트리에서 가장 왼쪽에 있는 노드가 된다.

특히, (1)의 경우 부모 노드를 리턴해야 하므로 루트에서 해당 노드 X를 찾아 갈 때 이전 부모 노드를 계속 트래킹 해 둘 필요가 있다.

*BinarySearchTree.BST.cs InorderSuccessor()메서드 참조

최소 공통 조상(Lowest Common Ancestor) 구하기

이진 탐색 트리에서 최소 공통 조상(LCA)을 구하는 것은 앞의 이진 트레이서 LCA를 구하는 것보다 단순하다.
두 수를 a,b 모두가 루트 노드보다 작으면 a,b는 왼쪽 서브트리에 있는 것이며, 반대로 a,b모두가 루트 노드보다 크면 a,b는 오른쪽 서브트리에 있다는 뜻이다.
만약 이 두 경우가 아니라면, 두 수는 양쪽에 하나씩 있다는 의미로서 루트가 LCA가 된다.
이러한 LCA로직은 재귀 방식이나 반복적 방식으로 구현할 수 있는데, 아래는 이 두가지 방식으로 LCA를 구현한 예제이다.

*BinarySearchTree.BST.cs IterativeLCA() 메서드 참조


이진 트리를 이진 탐색 트리로 변환하기

이진 트리의 트리 구조를 그대로 유지하면서 이진 탐색 트리로 변환하는 방법에 대해 생각해 보자.
이진 트리는 기본적으로 정렬되지 않은 트리이고 이를 정렬된 이진 탐색 트리로 변환하는 것이므로, 우선 이진 트리를 순회하여 모든 노드 키값을 배열에 저장한 후, 배열을 소트하여 정렬된 데이타 셋을 만든다.
(주: 배열을 사용하지 않고 .NET의 SortedList 클래스를 사용하면 소트를 별도로 수행하지 않아도 된다.)
다음 이진 트리를 다시 준위 순회하면서 차례로 배열에 저장된 값을 하나씩 넣어 주면 된다.
아래 예제는 이진 트리의 구조를 그대로 유지하면서 이진 탐색 트리로 변환하는 예이다.

*BinarySearchTree.BST.cs ConvertToBST() 메서드 참조