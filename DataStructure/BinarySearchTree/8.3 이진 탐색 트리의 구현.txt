8.3 이진 탐색 트리의 구현

이진 탐색 트리는 기본적으로 이진 트리와 동일한 노드 클래스를 사용한다.
이진 탐색 트리 클래스는 루트 노드를 내부 private 필드로 가지며, 필요한 메서드들을 pubilc으로 구현한다.
이진 탐색 트리 클래스는 보통 노드를 외부에 노출시킬 필요가 없어서 노드 클래스 역시 Nested private class로 구현할 수도 있다.

이진 탐색 트리 클래스에서 기본적으로 사용하는 메서드로는 노드 키 데이타를 추가할 때 사용하는 Add()메서드, 특정 키가 트리에 있는지 검색하는 Search()메서드, 키 데이타를 삭제하는 Remove()메서드 등이 있다.
아래 예제는 이러한 이진 탐색 트리 클래스의 기본 골격을 표현한 것이다.

*BinarySearchTree.BST.cs 참조

이진 탐색 트리의 추가 (Add) 메서드

이진 탐색 트리에 새 키 데이타를 추가하기 위해서는 먼저 루트 노드로부터 키를 비교하여 좌,우 노드로 계속 이독해 내려가면서 새 키를 추가할 장소를 찾는다.
즉, 키가 루트 혹은 서브트리의 루트보다 작으면 왼쪽 노드로 이동하고, 크면 오른쪽 노드로 계속 이동한다.
만약 이동한 노드가 null이 되면 그곳이 새 노드를 넣을 곳이 된다.
통상 새 노드는 부모 노드의 좌우 노드에 링크를 넣어야 하므로, 이동할 때 부모 노드에서 이동할 곳의 자식 노드가 null인지를 먼저 체크해서 부모 노드밑에 새 노드를 연결한다.
아래는 위의 BST<T> 클래스에서 생략한 Add()메서드를 구현한 예제이다.

*BinarySearchTree.BST.cs Add()메서드 참조


이진 탐색 트리의 탐색(Search) 메서드
이진 탐색 트리에서 특정 키 데이타가 있는지를 체크하는 방법은 비교적 간단하다.
즉, 루트 노드에서 출발하여 키가 작으면 왼쪽으로 ,크면 오른쪽으로 계속 이동해 가면서 같은 키값이 나오는 노드를 발견하면 true를 리턴하면 된다.
아래 예제는 이렇게 반복적으로 루프를 돌며 트리 노드를 이동하면서 Iterative 방식으로 탐색을 구현한 코드이다.

*BinarySearchTree.BST.cs Search()메서드 참조

Search 메서드를 구현하는 또 다른 방식으로 재귀 호출을 이용하는 방식이 있다.
즉, 루트 노드와 키를 비교해서 같으면 true를 리턴하고, 아니면 왼쪽 서브트리나 오른쪽 서브트리에서 동일한 메서드를 재귀 호출하여 양쪽 어느 한 곳에서 발견되면 true를 리턴하고 둘 다 발견 못하면 false를 리턴한다.
아래는 Recursive 호출로 구현한 탐색 예제이다.

*BinarySearchTree.BST.cs SearchRecursive()메서드 참조

이진 탐색 트리에서 탐색은 O(log n)의 시간 복잡도(Time Complexity)를 갖는다.
즉, 탐색을 루트로부터 한 노드씩 진행할 때마다 절반의 노드들을 계속 제거하기 때문에 전체 노드 n개에 대해 log n 의 시간 성능을 갖게 된다.


이진 탐색 트리의 삭제(Remove) 메서드

이진 탐색 트리의 삭제 메서드는 BST<T>의 메서드 중 가장 복작한 로직을 가진 메서드이다.
특정 노드를 삭제하기 위해서는 우선 해당 노드까지 검색을 수행해야 하고, 검색된 노드를 부모 노드에서 삭제해야 한다.
그런데, 이렇게 삭제할 때 삭제할 노드가 자식 노드를 가지고 있을 수 있기 때문에, 이 자식 노드들을 부모 노드 쪽에 붙여주는 문제가 생기게 된다.
이때 자식 노드가 몇 개인지에 따라 즉 삭제할 노드의 자식 노드가 0개, 1개, 2개 인가에 따라 서로 다른 방식으로 접목하게 된다.
자식노드가 0개인 경우, 부모 노드에서 간단히 삭제할 노드에 대한 링크를 null로 설정하여 삭제하면 된다.

자식노드가 1개인 경우, 부모 노드에서 삭제할 노드 자리에 왼쪽 혹은 오른쪽 자식노드를 대입하면 된다.
자식노드는 1개이므로 삭제할 노드 자리에 그대로 대입해도 이진 탐색 트리의 속성들이 모두 유지될 것이다.

자식노드가 2개인 경우는 좀 복잡하다.
이때는 삭제할 노드의 왼쪽 서브트리와 오른쪽 서브트리가 함께 존재하는데, 왼쪽 서브트리 중 가장 큰 수 혹은 오른쪽 서브트리의 가장 작은 수를 삭제할 노드 자리에 옮겨 놓으면 된다.
아래 예제에서는 오른쪽 서브트리에서 가장 작은 수 즉 오른쪽 서브트리에서 가장 왼쪽에 있는 노드를 찾아 이 키값을 삭제할 노드에 대입하였다.

오른쪽 서브트리의 가장 작은 수를 갖는 노드를 min(이하 민) 노드라고 했을 때, 민 노드 값을 삭제할 노드에 대입한 후에는 민 노드 자체를 삭제해야 한다.
민 노드는 서브트리에서 가장 왼쪽에 이쓴 노드이므로 민 노드의 왼쪽 노드는 항상 null이지만, 오른쪽 자식 노드는 null이 아닐 수 있으므로 이를 처리해 주어야 하는데, 이는 민 노드의 오른쪽 노드를 민 노드의 부모 노드에 링크하면 된다.
즉, 민 노드가 그 바로 위 부모 노드의 왼쪽 자식 노드인 경우, 민 노드의 오른쪽 노드를 그 부모 노드의 왼쪽 노드에 링크하고, 민 노드가 오른쪽 자식 노드인 경우는 민 노드의 오른쪽 노드를 그 부모 노드의 오른쪽 노드에 링크하면 된다.
이는 민 노드의 오른족 노드가 null인 경우에도 공히 적용할 수 있다.

*BinarySearchTree.BST.cs Remove()메서드 참조


이진 탐색 트리를 정렬된 배열로 변환

이진 탐색 트리를 순서대로 정렬된 배열로 변환하는 메서드를 작성해 보자.
이진 탐색 트리는 중위 순회를 하면 정렬된 데이타를 쉽게 얻을 수 있는데, 이를 그대로 바열에 담으면 된다.
트리 순회를 하면서 배열에 데이타를 담기 위해서는 순회를 하는 메서드에 배열을 입력 파라미터로 전달하고 그 배열에 데이타를 추가하면 된다.
아래는 중휘 순회를 통해 이진 탐색 트리를 정렬된 배열로 변환하는 예제이다.

*BinarySearchTree.BST.cs ToSortList()메서드 참조

이진 탐색 트리 테스트 프로그램

*BinarySearchTree.Example.cs Example1()메서드 참조

처음 BST에 노드를 모두 추가하면 아래 그림의 왼쪽과 같은 BST 트리가 생성되는데, 여기서 노드 2를 삭제하면 그림 오른쪽과 같은 트리로 변형된다.
노드 2의 오른쪽 서브트리에서 가장 왼쪽에 있는 3이 2 자리로 대입되고 3의 부모인 5 밑에 4가 옮겨 진다.