5. 스택(Stack)

5.1 Stack 자료구조

스택은 가장 최근에 넣은 데이타를 먼저 꺼내서 사용하는 선형적인 자료구조이다.
스택은 흔히 LIFO (Last In First Out)라고 불리우는 자료구조로서 나중에 저장된 것을 먼저 꺼내는 구조를 가지고 있다.

*이미지 참조

위 그림에서 보듯이, 스택은 새 데이타를 넣을 때 위쪽(top)에 데이타를 추가(push)하고, 데이타를 꺼낼 때는 다시 위쪽에서부터 데이타를 가져오는(pop) 구조를 갖는다.
스택은 흔히 배열이나 연결 리스트를 사용해서 구현하곤 한다.


5.2 배열로 구현한 Stack

배열을 사용하여 스택을 구현하는 가장 단순한 구현은 고정된 배열을 할당하고 스택의 top 인덱스를 사용하여 데이타를 넣고 가져오는 것을 구현하는 방식이다.
스택에서 새 데이타 요소를 추가하는 것을 푸쉬(Push)라 하고, 가장 마지막에 추가된 요소를 제거하며 가져오는 것을 팝(Pop)이라 한다.
이 푸쉬와 팝 동작은 스택의 가장 기본적인 행위(메서드)에 해당된다.
구현 방식에 따라 약간 다를 수 있지만 통상 Push()메서드에서는 top인덱스를 하나 증가시킨 후 새 요소를 추가하고, 
Pop()메서드에서는 top 인덱스가 가리키는 위치에 요소 데이타를 가져오고 top 인덱스를 하나 감소시킨다.

아래는 배열을 사용하여 구현한 간단한 Stack 클래스에 대해 예제이다.

*Stack.StackUsingArray.cs 참조

위 메서드들의 주요 기능을 요약하면,
 
 - 생성자 : Stack 클래스 생성자에서는 먼저 지정된(혹은 디폴트) 크기의 배열을 생성하고 top 인덱스를 -1로 설정한다.
 - Push() : 새 요소를 추가하는 메서드로서, 먼저 스택이 가득 찬 상태인지 체크하고, 차지 않았으면 top 인덱스를 하나 증가시킨 후 새 요소를 추가한다.
			만약 가득 찬 상태이면, Exception을 throw 하던지 현재 배열의 크기를 2배로 확대한 후 기존 요소들을 새 배열에 복사하여 스택 크기를 확장하는 방법을 사용할 수 있다.
			둘 중 어떤 방법을 선택하는가는 확장 기능을 구현할 것인지 말지에 달려 있다.
 - Pop() : 스택의 최상단 즉 top 인덱스 위치에서 한요소를 제거하면서 그 값을 리턴하는 메서드이다.
		   먼저 스택이 비어 있는지 체크하고, 비어있으면 메시지를 표시하거나 Exception을 throw한다.
 - Peek() : 스택의 최상단에 있는 요소를 제거하지 않으면서 그 데이타값만을 체크하기 위해 Peek()메서드를 사용한다.
			Pop() 메서드와 다른 점은 Peek()는 top 인덱스를 감소시키지 않아 현재 요소를 제거하지 않는다는 점이다.
			

5.3 연결리스트로 구현한 Stack

연결 리스트는 그 구조가 일렬로 데이타를 연결하고 있다는 점에서 스택을 구현하는데 쉽게 이용될 수 있다.
다만, 연결 리스트로 스택을 구현하기 위해서는 마지막 노드 뒤에 새 노드를 추가하는 것이 아니라, 아래 그림처럼 스택의 top 포인터에 새 노드를 추가하면서
새 노드를 Next 포인터가 이전 노드를 가리키도록 해야한다.

*이미지 참조

Stack에서 데이타를 꺼내오는 동작은 top 포인터의 데이타를 리턴하면서 top 포인터를 top의 아래 노드에 설정하면 된다.

아래 예제는 단일 연결 리스트를 사용하여 스택을 구현한 샘플코드이다.

*Stack.StackUsingLinkedList.cs 참조

위 예제에서 Node 클래스는 Stack 클래스 안에 private class로 정의되어 있다.
Node 클래스를 private으로 지정함으로써 Node 클래스는 Stack 클래스 내부에서만 사용할 수 있게 된다.

연결 리스트로 구현한 스택의 시간 성능은 푸쉬와 팝에서 모두 O(1)을 갖게 된다.
또한 이 방식은 메모리가 허용하는 한 무제한의 공간을 사용할 수 있기 때문에 배열 처럼 스택이 가득 차거나 배열을 다시 확장해야 하는 문제를 갖지 않는다.


5.4 .NET의 Stack 클래스

닷넷에서 스택을 지원하는 클래스로는 (1)Stack 요소들이 object 타입인 System.Collections.Stack 클래스와 
(2) 개발자가 Stack 생성시 요소들의 타입을 결정할 수 있는 제네릭(Generic) 타입의 System.Collections.Generic.Stack<T> 클래스,
그리고 (3) 멀티쓰레딩 환경에서 스택을 간편하게 사용할 수 있도록 .NET 4.0부터 제공된 ConcurrentStack<T> 클래스가 있다.

닷넷의 Stack<T> 클래스와 Stack 클래스는 요소타입을 지정할 수 있는 제네릭인가 아닌가하는 차이가 있으며, 두 클래스는 닷넷의 큐 클래스와 마찬가지로 내부적으로 원형 동적 배열로 구현되어 있다.
즉, 이들 클래스는 원형 배열을 사용하여 스택을 구현하였는데, 스택이 가득 찼을 때 2배의 원형 배열을 만들어 스택을 확장하는 기능을 가지고 있다.

아래 예제는 Stack<T>를 사용하여 double형 Stack을 만들고 데이타를 넣고 빼는 샘플코드이다.

{
	Stack<double> s = new Stack<double>();
	s.Push(1.25d);
	s.Push(2.50d);
	s.Push(3.75d);
	
	double val = s.Pop(); // 3.75
	Console.WriteLine(val);
}

.NET 4.0부터 제공되는 ConcurrentStack<T> 클래스는 System.Collections.Concurrent 네임스페이스에 있는 클래스로서 이전에 소개한 ConcurrentQueue<T> 와
비슷하게 멀티쓰레드들이 동시에 스택에 데이타를 넣고 꺼낼 때 유용하게 사용될 수 있다.

이래 예제는 하나의 쓰레드가 ConcurrentStack<T>에 0부터 99까지 계속 집어 넣을 때, 동시에 다른 쓰레드에서는 계속 그 스택에서 데이타를 빼내 읽어 오는 작업을 하는 샘플 코드이다.
이 예제에서 하나의 쓰레드는 100ms 간격을 두고 스택에 데이타를 푸쉬하고 있으며, 다른 쓰레드는 150ms 간격을 두고 데이타를 팝하고 있다.
이렇게 인위적으로 팝하는 속도는 약간 늦춤으로 해서 0부터 99까지 순차적으로 출력되지 않을 가능성이 더 커지게 된다.

*Stack.Example.cs Example1() 참조


5.5 스택의 활용 - 수식계산

스택은 다양한 분야에 활동되는데, 여기서는 수식 계산에 스택을 활용하는 과정을 살펴본다.
수식(Expression)은 연산자(Operator)와 연산자(Operand)로 구성되어 있는데, 
연산자의 위치에 따라 전위표기(Prefix Notation), 중위표기(Infix Notation), 후위표기(Postfix Notation)로 표현할 수 있다.

예를 들어, 수식 "1 + 22"는 각 표기법에 따라 다음과 같이 표현할 수 있다.

	전위표기 : + 1 22
	중위표기 : 1 + 22
	후위표기 : 1 22 +
	
사람들이 사용하는 수식 표기법은 중위표기법인데, 컴퓨터에서 중위표기를 사용하면 여러가지 불편한 점이 있다.
중위표기법은 괄호와 연산자 우선순위를 고려해서 처리해야 하지만, 후위표기법은 괄호나 우선순위가 따로 없으면 왼쪽에서 오른쪽으로 순서대로 처리하면 된다.
컴퓨터에서 수식을 처리할 때는 후위표기법이 가장 효율적이다.

수식은 여러가지 복잡한 연산을 표현할 수 있는데, 여기서는 간단하게 사칙연산만을 처리하는 과정에 대해 살펴보자.
수식을 처리하는 프로그램은 보통 아래와 같이 3가지 부분으로 나누어 질 수 있다.

	1. 먼저 수식을 문자열로 받아들여 이를 토큰화(Tokenize)하는 부분인데, 일반적으로 연산자, 피연산자, 괄호 등을 분석해서 토큰 컬렉션으로 만든다.
	   토큰화 과정을 거친 토큰은 보통 토큰타입(Token type)과 토큰값(Token value)을 갖는다.
	   예를 들어, 수식 "1 + 22"는 3개의 토큰(즉1, +, 22)을 갖게 된다.
	2. 다음으로 중위표기가 되어 있는 것을 스택을 활용하여 후위표기로 변환하는 부분이다.
	3. 마지막으로 후휘표기가 되어 있는 부분을 스택을 사용하여 계산하는 부분이다.
	
수식 계산에서 스택을 활용하는 부분에 포커스하기 위해, 여기서는 토큰화하는 부분은 생략하고, 중위표기를 후위표기로 변환 후 후위표기로부터 식을 계산하는 부분만 살펴보도록 하자.

중위표기를 후위표기로 변환하는 로직은 다음과 같다.

	1. 후위표기 결과를 담는 리스트(이하 postfix)를 초기화한다.
	2. 연산자를 저장할 수 있는 스택을 초기화한다.
	3. 중위표기로 표현된 토큰들을 루프를 돌며 아래 로직에 따라 하나씩 처리한다.
		- 토큰이 피연산자이면, postfix에 추가한다.
		- 토큰이 연산자이면, 스택의 최상위 노드에 있는 연산자가 토큰 연산자보다 우선순위가 높거나 같으면 스택에 팝 하여 postfix에 추가한다.
		  이 과정을 반복해서 스택의 토큰 연산자보다 우선순위가 낮은 연산자가 있거나 스택이 빌 때까지 계속 수행한다.
		  우선순위는 괄호 (, )가 가장 낮고, 다음이 +,- 그리고 다음으로 *,/ 가 가장 높다.
		  예를들어, 토큰이 + 혹은 - 이면, 스택에서 *,/,+,- 연산자가 있는 경우 모두 Pop한다.
		  만약 토큰이 * 혹은 - 이면, 스택에서 *,/ 연산자인 경우만 Pop한다.
	    - 토큰이 '(' 괄호이면, 스택에 추가한다.
		- 토큰이 ')' 괄호이면, 스택에서 '(' 이 나올 때까지 계속 Pop하여 postfix에 추가한다.
		  단 스택에 있는 '(' 은 postfix에 추가하지 않는다.
	4. 중위표기로 포현된 토큰들을 모두 처리한 후, 스택에 남은 연산자를 모두 postfix에 추가한다.
	
이어 후위표기로부터 식을 계산하는 부분은 좀 더 간단하다.
아래는 스택을 이용하여 후위표기로부터 식을 계산하는 기본 로직이다.

	1. 피연산자 또는 결과를 저장할 수 있는 스택을 미리 생성한다.
	2. 후위표기 식을 왼쪽에서부터 오른쪽으로 토큰 단위로 하나씩 처리한다.
	3. 토큰이 피연산자이면 스택에 추가한다.
	4. 토큰이 연산자이면 스택에서 이미 넣어둔 2개의 피연산자를 꺼내 연산한 후 결과를 다시 스택에 넣는다.
	5. 위 과정을 반복하면 마지막에 최종 결과만 스택에 남게된다. 이를 Pop 하여 최종결과를 리턴한다.
	
위에서 소개한 후위표기 변환과 식 계산 로직을 토대로 아래와 같이 간단한 사칙연산 프로그램을 작성할 수 있다.
토큰화 과정을 생략하였기 때문에 테스트 코드에서 샘플에 사용한 식은 각 토큰 사이에 공백을 넣어 간단한 토큰 배열로 만들수 있게 하였다.

*Stack.Calculator.cs, Stack.Example.cs Example2() 참조