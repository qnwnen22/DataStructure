8. 이진 탐색 트리 (Binary Search Tree)

8.1 이진 탐색 트리 자료구조

이진 탐색 트리(BST)란 이진 트리 중 왼쪽 노드의 값이 루트 노드의 값보다 작고, 오른쪽 노드의 값이 루트 노드의 값보다 큰 값을 갖는 트리를 가리키는데, 이러한 값 순서는 이진 탐색 트리의 모든 서브트리에 적용된다.

다시 말하면, 이진 탐색 트리는 다음과 같은 속성을 갖는다.

 - 왼쪽 서브트리의 키들은 루트의 키보다 작다.
 - 오른쪽 서브트리의 키들은 루트의 키보다 크가.
 - 왼쪽 서브트리와 오른쪽 서브트리는 그 자체로 이진 탐색 트리이다.
 
이진 탐색 트리를 정의할 때, 모든 노드의 키가 유일(Unique)하다는 정의를 포함시키는 것이 일반적이지만, 일부에서는 중복된 값을 허용하는 경우도 있다.
중복을 허용하는 이진 탐색 트리의 경우 왼쪽 서브트리는 루트보다 작거나 같게 되고, 오른쪽 서브트리는 루트보다 크거나 같게 된다.

이진 탐색 트리는 왼쪽에서 루트를 통해 오른쪽으로 순서에 맞춰 키가 정렬되어 있어서 Ordered Binary Tree 혹은 Sorted Binary Tree 라고도 불리운다.

아래 그림은 간단한 이진 탐색 트리의 예이다.

*이미지 참조


8.2 이진 탐색 트리 순회(Traversal)

이진 탐색 트리의 순회는 기본적으로 이진 트리와 동일한 순회 방식을 사용한다.

이진 탐색 트리를 순회할 때는 주로 중위 순회(Inorder Traversal) 방식을 사용하는데, 중위 순회를 하면 이진 탐색 트리내에 있는 값들을 순서대로 정렬해서 읽을 수 있기 때문이다.
예를 들어, 위 그림의 이진 탐색 트리를 중위 순회로 읽으면 1,3,5,7,9,11,13 과 같이 순서대로 읽게 된다.


8.3 이진 탐색 트리의 구현

이진 탐색 트리는 기본적으로 이진 트리와 동일한 노드 클래스를 사용한다.
이진 탐색 트리 클래스는 루트 노드를 내부 private 필드로 가지며, 필요한 메서드들을 pubilc으로 구현한다.
이진 탐색 트리 클래스는 보통 노드를 외부에 노출시킬 필요가 없어서 노드 클래스 역시 Nested private class로 구현할 수도 있다.

이진 탐색 트리 클래스에서 기본적으로 사용하는 메서드로는 노드 키 데이타를 추가할 때 사용하는 Add()메서드, 특정 키가 트리에 있는지 검색하는 Search()메서드, 키 데이타를 삭제하는 Remove()메서드 등이 있다.
아래 예제는 이러한 이진 탐색 트리 클래스의 기본 골격을 표현한 것이다.

*BinarySearchTree.BST.cs 참조

이진 탐색 트리의 추가 (Add) 메서드

이진 탐색 트리에 새 키 데이타를 추가하기 위해서는 먼저 루트 노드로부터 키를 비교하여 좌,우 노드로 계속 이독해 내려가면서 새 키를 추가할 장소를 찾는다.
즉, 키가 루트 혹은 서브트리의 루트보다 작으면 왼쪽 노드로 이동하고, 크면 오른쪽 노드로 계속 이동한다.
만약 이동한 노드가 null이 되면 그곳이 새 노드를 넣을 곳이 된다.
통상 새 노드는 부모 노드의 좌우 노드에 링크를 넣어야 하므로, 이동할 때 부모 노드에서 이동할 곳의 자식 노드가 null인지를 먼저 체크해서 부모 노드밑에 새 노드를 연결한다.
아래는 위의 BST<T> 클래스에서 생략한 Add()메서드를 구현한 예제이다.

*BinarySearchTree.BST.cs Add()메서드 참조


이진 탐색 트리의 탐색(Search) 메서드
이진 탐색 트리에서 특정 키 데이타가 있는지를 체크하는 방법은 비교적 간단하다.
즉, 루트 노드에서 출발하여 키가 작으면 왼쪽으로 ,크면 오른쪽으로 계속 이동해 가면서 같은 키값이 나오는 노드를 발견하면 true를 리턴하면 된다.
아래 예제는 이렇게 반복적으로 루프를 돌며 트리 노드를 이동하면서 Iterative 방식으로 탐색을 구현한 코드이다.

*BinarySearchTree.BST.cs Search()메서드 참조

Search 메서드를 구현하는 또 다른 방식으로 재귀 호출을 이용하는 방식이 있다.
즉, 루트 노드와 키를 비교해서 같으면 true를 리턴하고, 아니면 왼쪽 서브트리나 오른쪽 서브트리에서 동일한 메서드를 재귀 호출하여 양쪽 어느 한 곳에서 발견되면 true를 리턴하고 둘 다 발견 못하면 false를 리턴한다.
아래는 Recursive 호출로 구현한 탐색 예제이다.

*BinarySearchTree.BST.cs SearchRecursive()메서드 참조

이진 탐색 트리에서 탐색은 O(log n)의 시간 복잡도(Time Complexity)를 갖는다.
즉, 탐색을 루트로부터 한 노드씩 진행할 때마다 절반의 노드들을 계속 제거하기 때문에 전체 노드 n개에 대해 log n 의 시간 성능을 갖게 된다.


이진 탐색 트리의 삭제(Remove) 메서드

이진 탐색 트리의 삭제 메서드는 BST<T>의 메서드 중 가장 복작한 로직을 가진 메서드이다.
특정 노드를 삭제하기 위해서는 우선 해당 노드까지 검색을 수행해야 하고, 검색된 노드를 부모 노드에서 삭제해야 한다.
그런데, 이렇게 삭제할 때 삭제할 노드가 자식 노드를 가지고 있을 수 있기 때문에, 이 자식 노드들을 부모 노드 쪽에 붙여주는 문제가 생기게 된다.
이때 자식 노드가 몇 개인지에 따라 즉 삭제할 노드의 자식 노드가 0개, 1개, 2개 인가에 따라 서로 다른 방식으로 접목하게 된다.
자식노드가 0개인 경우, 부모 노드에서 간단히 삭제할 노드에 대한 링크를 null로 설정하여 삭제하면 된다.

자식노드가 1개인 경우, 부모 노드에서 삭제할 노드 자리에 왼쪽 혹은 오른쪽 자식노드를 대입하면 된다.
자식노드는 1개이므로 삭제할 노드 자리에 그대로 대입해도 이진 탐색 트리의 속성들이 모두 유지될 것이다.

자식노드가 2개인 경우는 좀 복잡하다.
이때는 삭제할 노드의 왼쪽 서브트리와 오른쪽 서브트리가 함께 존재하는데, 왼쪽 서브트리 중 가장 큰 수 혹은 오른쪽 서브트리의 가장 작은 수를 삭제할 노드 자리에 옮겨 놓으면 된다.
아래 예제에서는 오른쪽 서브트리에서 가장 작은 수 즉 오른쪽 서브트리에서 가장 왼쪽에 있는 노드를 찾아 이 키값을 삭제할 노드에 대입하였다.

오른쪽 서브트리의 가장 작은 수를 갖는 노드를 min(이하 민) 노드라고 했을 때, 민 노드 값을 삭제할 노드에 대입한 후에는 민 노드 자체를 삭제해야 한다.
민 노드는 서브트리에서 가장 왼쪽에 이쓴 노드이므로 민 노드의 왼쪽 노드는 항상 null이지만, 오른쪽 자식 노드는 null이 아닐 수 있으므로 이를 처리해 주어야 하는데, 이는 민 노드의 오른쪽 노드를 민 노드의 부모 노드에 링크하면 된다.
즉, 민 노드가 그 바로 위 부모 노드의 왼쪽 자식 노드인 경우, 민 노드의 오른쪽 노드를 그 부모 노드의 왼쪽 노드에 링크하고, 민 노드가 오른쪽 자식 노드인 경우는 민 노드의 오른쪽 노드를 그 부모 노드의 오른쪽 노드에 링크하면 된다.
이는 민 노드의 오른족 노드가 null인 경우에도 공히 적용할 수 있다.

*BinarySearchTree.BST.cs Remove()메서드 참조


이진 탐색 트리를 정렬된 배열로 변환

이진 탐색 트리를 순서대로 정렬된 배열로 변환하는 메서드를 작성해 보자.
이진 탐색 트리는 중위 순회를 하면 정렬된 데이타를 쉽게 얻을 수 있는데, 이를 그대로 바열에 담으면 된다.
트리 순회를 하면서 배열에 데이타를 담기 위해서는 순회를 하는 메서드에 배열을 입력 파라미터로 전달하고 그 배열에 데이타를 추가하면 된다.
아래는 중휘 순회를 통해 이진 탐색 트리를 정렬된 배열로 변환하는 예제이다.

*BinarySearchTree.BST.cs ToSortList()메서드 참조

이진 탐색 트리 테스트 프로그램

*BinarySearchTree.Example.cs Example1()메서드 참조

처음 BST에 노드를 모두 추가하면 아래 그림의 왼쪽과 같은 BST 트리가 생성되는데, 여기서 노드 2를 삭제하면 그림 오른쪽과 같은 트리로 변형된다.
노드 2의 오른쪽 서브트리에서 가장 왼쪽에 있는 3이 2 자리로 대입되고 3의 부모인 5 밑에 4가 옮겨 진다.


8.4 이진 탐색 트리의 몇가지 알고리즘

이진 탐색 트리를 사용하면서 유용하게 사용되는 몇가지 알고리즘을 소개한다.

K번째 작은 수 혹은 K번째 큰 수 구하기

이진 탐색 트리에서 K번째로 작은 수를 구하는 코드를 생각해 보자.
이진 탐색 트리를 중위 순회하면 정렬된 데이타를 얻을 수 있으므로, 이를 배열에 담고 K번째로 작은 배열 요소를 찾으면 쉽게 문제를 해결할 수 있다.
그러나, 이렇게 추가적인 배열을 사용하지 않고도 문제를 해결할 수도 있다.
즉, 트리를 순회해 나가면서 K번째 작운 수를 구할 수도 있다.
아래 예제는 순회와 동시에 K번째 작은 수를 찾는 방식으로 count변수를 전달하여 현재 노드가 순위상 몇 번째 노드인지를 함께 체크하고 있다.

*BinarySearchTree.BST.cs FindKthSmallest()메서드 참조

위와 비슷한 방식으로 K번째 큰 수를 구할 수도 있는데, 차이점은 위의 중위 순회가 왼쪽 - 루트 - 오른쪽 순으로 이동하였다면, K번째 큰 수는 반대로 오른쪽 - 루트 - 왼쪽 순으로 이동하면 내림차순으로 노드를 순회할 수 있게 된다.
아래는 순회와 동시에 K번째 큰 수를 찾는 예제이다.

*BinarySearchTree.BST.cs FindKthLargest()메서드 참조

중위 순회에서 특정 노드의 다음 노드 찾기

이진 탐색 트리를 중위 순회할 때 어느 한 노드 바로 다음에 오는 노드(Successor)를 찾아 보도록 하자.
중위 순회에서 임의의 노드 X의 다음 노드는 (1) X의 오른쪽 자식 노드가 없을 경우 X의 부모 노드가 되고, (2) X의 오른쪽 서브트리가 있을 경우 오른쪽 서브트리에서 가장 왼쪽에 있는 노드가 된다.

특히, (1)의 경우 부모 노드를 리턴해야 하므로 루트에서 해당 노드 X를 찾아 갈 때 이전 부모 노드를 계속 트래킹 해 둘 필요가 있다.

*BinarySearchTree.BST.cs InorderSuccessor()메서드 참조

최소 공통 조상(Lowest Common Ancestor) 구하기

이진 탐색 트리에서 최소 공통 조상(LCA)을 구하는 것은 앞의 이진 트레이서 LCA를 구하는 것보다 단순하다.
두 수를 a,b 모두가 루트 노드보다 작으면 a,b는 왼쪽 서브트리에 있는 것이며, 반대로 a,b모두가 루트 노드보다 크면 a,b는 오른쪽 서브트리에 있다는 뜻이다.
만약 이 두 경우가 아니라면, 두 수는 양쪽에 하나씩 있다는 의미로서 루트가 LCA가 된다.
이러한 LCA로직은 재귀 방식이나 반복적 방식으로 구현할 수 있는데, 아래는 이 두가지 방식으로 LCA를 구현한 예제이다.

*BinarySearchTree.BST.cs IterativeLCA() 메서드 참조


이진 트리를 이진 탐색 트리로 변환하기

이진 트리의 트리 구조를 그대로 유지하면서 이진 탐색 트리로 변환하는 방법에 대해 생각해 보자.
이진 트리는 기본적으로 정렬되지 않은 트리이고 이를 정렬된 이진 탐색 트리로 변환하는 것이므로, 우선 이진 트리를 순회하여 모든 노드 키값을 배열에 저장한 후, 배열을 소트하여 정렬된 데이타 셋을 만든다.
(주: 배열을 사용하지 않고 .NET의 SortedList 클래스를 사용하면 소트를 별도로 수행하지 않아도 된다.)
다음 이진 트리를 다시 준위 순회하면서 차례로 배열에 저장된 값을 하나씩 넣어 주면 된다.
아래 예제는 이진 트리의 구조를 그대로 유지하면서 이진 탐색 트리로 변환하는 예이다.

*BinarySearchTree.BST.cs ConvertToBST() 메서드 참조
