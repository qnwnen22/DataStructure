3.1 연결 리스트의 기초개념

연결 리스트(Linked List)는 각 노드가 데이터와 포인터를 가지고 있으면서 노드들이 한 줄로 쭉 연결되어 있는 방식으로 데이터를 저장하는 자료구조이다.
노드들이 한 방향으로 각 노드가 다음 노드를 가리키고 있는 리스트를 단일 연결 리스트(Singly Linked List)라 하고,
각 노드가 이전 노드와 다음 노드를 모두 가리키는 양방향 노드로 되어 있는 것을 이중 연결 리스트(Doubly Linked List)라 한다.


3.2 단일 연결 리스트

단일 연결 리스트는 단뱡향으로 노드들이 연결한 간단한 자료구조이다.
아래는 4개의 노드를 갖는 단일 연결 리스트를 표현한 예이다.

*이미지 참조

단일 연결 리스트를 구현하기 위해서는 먼저 노드를 표현하는 노드 클래스와 이를 연결한 리스트인 링크드 리스트 클래스를 만들면 된다.
단일 연결 리스트의 노드 클래스는 그 노드가 기본적으로 가지고 있는 데이타 필드와 다음 노드를 가리키는 포인터를 가지고 있다.
C#으로 아래와 같이 간단한 노드 클래스를 표현할 수 있다.

*LinkedList.SinglyLinkedListNode.cs 참조

이들 노드들을 단방향으로 연결한 단일 연결 리스트 클래스는 리스트의 첫 노드를 가리키는 헤드(Head) 필드를 가지게 되는데,
이 헤드를 사용하여 전체 리스트를 순차적으로 엑세스하게 된다.

단일 연결 리스트 클래스는 리스트의 기본적인 기능을 지원하기 위해서 새 노드를 추가하는 Add()메서드, 새 노드를 중간에 삽입하는 AddAfter()메서드, 지정한 위치에 있는 노드를 반환하는 GetNode()메서드,
그리고 특정 노드를 지우는 Remove()메서드 등을 구현할 수 있다.
아래는 이러한 기본 메서드들을 구현한 간단한 단일 연결 리스트 클래스 예제이다.

*LinkedList.SinglyLinkedListNode.cs 참조

위 메서드들의 기능을 요약하면 아래와 같다.

 - Add(newNode)메서드 : 리스트가 비어 있으면 Head에 새 노드를 할당하고, 비어 있지 않으면 마지막 노드를 찾아 이동한 후 마지막 노드 다음에 새 노드를 추가한다.
 (주:만약 위에 SinglyLinkedList클래스에서 Head와 함께 Tail필드를 추가하고 마지막 노드를 Tail 필드에 저장한다면,
 Add 메서드에서 새 노드를 추가할 때 Tail이 가리키는 마지막 노드 다음에 직접 새 노드를 추가할 있다.

 - AddAfter(currNode, newNode)메서드 : 새 노드의 Next에 현재 노드의 Next를 먼저 할당하고, 현재 노드의 Next에 새노드를 할당한다.
 
 - Remove(removeNode)메서드 : 삭제할 노드가 첫 노드이면, Head의 다음노드 즉 두번째 노드를 Head에 할당하고, 첫 노드가 아니면 해당노드를 검색하여 삭제한다.
							 해당 노드를 검색할 때,단일 연결 리스트는 단방향으로 연결되어 있으므로 삭제할 노드의 바로 이전 노드를 찾아서 삭제 노드를 지워야 한다.
							 즉, 이전 노드에 Next에 삭제노드의 Next를 할당해야 지울 수 있다.
							 (주: 여기서 Remove() 메서드의 한 변형으로 RemoveAfter(previousNode) 와 같은 메서드를 작성한다면 이미 삭제한 노드의 이전 노드를 이미 알고 있으므로 삭제는 포인터만 변경해 주면 될 것이다.
 
 - GetNode(index) 메서드 : 단일 연결 리스트에서 특정 위치 인덱스에 있는 노드를 리턴한다.
						  만약 인덱스가 연결리스트 범위를 벗어나면 null을 리턴한다.
						  배열은 인덱스를 통해 즉시 배열요소를 찾을 수 있지만(즉, O(1)의 검색 성능), 
						  링크드 리스트는 해당 인덱스 만큼 계속 이동해서 노드를 찾아야 하므로 O(n)의 검색 시간을 갖는다.
 
 - Count() 메서드 : Head 부터 마지막 노드까지 이동하면서 카운트를 증가시킨다.
 
위에서 구현한 단일 연결 리스트의 기본 기능을 테스트 하기 위하여, 
아래 예제는 단일 연결 리스트에 0,1,2,3,4 요소를 추가하고, 중간의 2를 삭제하고 대신 100을 넣은 후, 리스트 전체를 출력하는 것을 테스트한 코드이다.

*LinkedList.Example.cs Example1() 참조


3.3 이중 연결 리스트

이중 연결 리스트(Doubly Linked List)는 단반향으로 연결된 단일 연ㄴ결 리스트의 탐색 기능을 개선한 것으로서 
리스트 안의 노드가 이전 노드와 다음 노드를 가리키는 포인터를 모두 가지고 있어서 양방향으로 탐색이 가능한 자료구조이다.

예를 들어, 아래 그림은 4개의 노드를 갖는 이중 연결 리스트를 표현한 예이다.

*이미지 참조

이중 연결 리스트를 구현하기 위해서는 단일 연결 리스트와 비슷하게 먼저 노드를 표현하는 노드 클래스와 이를 연결한 리스트인 이중 연결 리스트 클래스를 만들면 된다.

이중 연결 리스트의 노드 클래스는 그 노드가 기본적으로 가지고 있는 데이타 필드와 이전 노드와 다음 노드를 가리키는 2개의 포인터(주: C#에서의 레퍼런스)를 가지고 있다.
C#으로 표현하면 아래와 같이 노드 클래스를 표현할 수 있는데, 단일 연결 리스트가 Next 레퍼런스만 가진 반면, 이중 연결 리스트는 Prev와 Next 레퍼런스를 가진다.

*LinkedList.DoublyLinkedListNode.cs 참조

이들 노드들을 양방향으로 연결한 이중 연결 리스트는 리스트의 처음을 가리키는 헤드(Head) 필드가 필요하고, 경우에 따라 마지막 노드를 가리키는 Tail 필드를 추가할 수 있다.

이중 연결 리스트 클래스의 기본적인 기능을 지원하기 위해 구현하는 메서드는 단일 연결 리스트와 비슷한데,
새 노드를 추가하는 Add() 메서드, 새 노드를 중간에 삽입하는 AddAfter() 메서드, 지정한 위치에 있는 노드를 반환하는 GetNode() 메서드,
그리고 특정 노드를 지우는 Remove() 메서드 등을 들 수 있다.

아래는 이러한 기본 메서드들을 구현한 간단한 이중 연결 리스트 예제이다.

*LinkedList.DoublyLinkedList.cs 참조

위 메서드들의 기능을 요약하면 아래와 같다.

 - Add() : 리스트가 비어 있으면 head에 새 노드를 할당하고, 비어 있지 않으면 마지막 노드를 찾아 이동한 후 마지막 노드 다음에 새 노드를 추가한다.
 - AddAfter() : 현재 노드를 A, 새로 추가하는 노드를 B, 현재 노드의 다음 노드를 C라고 가정 했을 때,
				A.Next 레퍼런스를 B에 연결하고, C.Prev 레퍼런스를 B에 연결하고, B의 Prev를 A에, B의 Next를 C에 연결한다.
				이렇게 각 노드의 이전 노드와 다음 노드 레퍼런스만 수정해 주기 때문에 이 메서드는 O(1)의 처리 시간을 갖는다.
 - Remove() : 삭제할 노드가 첫 노드이면, Head의 다음 노드 즉 두번쨰 노드를 Head에 할당하고,
			  첫 노드가 아니면 삭제할 노드의 이전 노드와 다음 노드를 서로 연결한다.
			  단일 연결 리스트와 달리 이중 연결 리스트는 이전노드를 가지고 있으므로, 삭제 시 이전 노드를 검색할 필요가 없이
			  즉시 이전 노드와 다음 노드를 연결할 수 있다. 이 메서드는 O(1)의 처리 시간을 갖는다.
 - GetNode() : 이중 연결 리스트에서 특정 위치 인덱스에 있는 노드를 리턴한다.
			   만약 인덱스가 리스트 밖에 있으면, null을 리턴한다.
			   이중 연결 리스트는 해당 인덱스 만큼 계속 이동해서 노드를 찾아야 하므로 O(n)의 처리 시간을 갖는다.
 - Count() : Head부터 마지막 노드까지 이동하면서 카운트를 증가 시킨다. 역시 O(n)의 처리 시간을 갖는다.
 
아래 예제는 위에서 구현한 이중 연결 리스트의 기본 기능을 테스트 하기 위한 코드로, 
이중 연결 리스트에 0,1,2,3,4 요소를 추가하고 중간의 2를 삭제하고 대신 100을 넣은 후 전체 리스트를 순방향과 역방향으로 출력하는 것 이다.

*LinkedList.Example.cs Example2() 참조


3.4 원형 연결 리스트

원형 연결 리스트(Circular Linked List)는 환형 연결 리스트라고도 하는데, 일반 연결 리스트에서 마지막 노드를 처음 노드에 연결시켜 원형으로 만든 구조이다.
원혁 연결 리스트를 단방향으로 연결한 것을 원형 단일 연결 리스트(Singly Circular Linked List)라 하고, 
양방향으로 연결한 것을 원형 이중 연결 리스트(Doubly Circular Linked List)라 한다.

아래 그림은 4개의 노드를 갖는 원형 이중 연결 리스트를 포현한 예이다.
그림에서 보듯이, 첫 노드의 이전(Prev)노드는 마지막 노드를 가리키고, 마지막 노드의 다음(Next)노드는 첫 노드를 가리키고 있다.

*이미지 참조

원형 연결 리스트의 구현은 앞에서 소개한 단일 연결 리스트 혹은 이중 연결 리스트에서 처음과 마지막 노드를 서로 연결하는 것만을 추가해 주면 된다.
즉, 원형 단일 연결 리스트는 단일 연결리스트의 마지막 노드의 다음노드를 첫 노드를 가리키도록 하면 되고,
원형 이중 연결 리스트는 마지막 노드의 다음노드를 첫 노드를 가리키도록 함과 동시에 아래 예제는 원형 이중 연결 리스트를 간략히 구현해 본 것이다.

*LinkedList.CricularLinkedList.cs 참조

위 메서드들의 기능을 요약하면 아래와 같다.

 - Add() : 리스트가 비어 있으면 Head에 새 노드를 할당하고, 비어 있지 않으면 첫 노드의 이전노드인 마지막 노드를 찾고 첫노드와 마지막 노드 사이에 새 노드를 추가한다.
		   원형 이중 연결 리스트는 일반 이중 연결 리스트와 달리 마지막 노드를 찾기 위해 모든 노드를 순차적으로 이동할 필요가 없다.
		   워내하면, 첫 노드의 이전 노드가 항상 마지막 노드를 가리키고 있기 때문이다 바로 마지막 노드를 알아 낼 수 있기 때문이다.
		   
 - AddAfter() : 이는 이중 연결 리스트와 동일한 메서드이다. 
				단, 이중 연결 리스트는 마지막 노드 다음이 null이어서 current.Next.Prev문장에 대해 current.Next가 null 인지 먼저 체크해야 하지만,
				원형 이중 연결 리스트는 마지막 노드 다음이 헤드이므로 별도로 null을 체크할 필요가 없다.
				
 - Remove() : 삭제할 노드가 첫 노드이고 전체 노드의 수가 하나이면, 헤드를 null로 설정한다.
			  이 경우가 아니면, 삭제할 노드의 이전 노드와 다음 노드를 서로 연결하는 작업을 진행하고, 삭제할 노드를 null로 설정한다.
			  
 - GetNode() : 이중 연결 리스트에서 특정 위치 인덱스에 있는 노드를 리턴한다.
			   리스트가 원형이므로 루프를 돌려 이동할 때 다시 순환해서 헤드로 돌아오면 찾는 노드가 없는 것이므로 null을 리턴한다.
			   
 - Count() : Head 부터 마지막 노드까지 이동하면서 카운트를 증가시킨다.
			 마지막 노드의 다음 노드로 이동하면 Head를 만나게 되므로 이러한 조건일 때 루프를 중지하면 된다.
			 
아래 예제는 위에서 구현한 원형 이중 연결 리스트의 기본 기능을 테스트 하기 위한 코드로,
원형 연결 리스트에 0,1,2,3,4 요소를 추가하고 중간의 2를 삭제하고 대신 100을 넣은 후 전체 르스트를 두번 출력해 본 것이다.
리스트가 원형이므로 전체 리스트 카운터의 2배 만큼 계속 이동하면 리스트를 두번 출력하게 된다.

*LinkedList.Example.cs Example3() 참조

원형 연결 리스트인지 체크

원형 연결 리스트에서 한가지 추가적으로 살펴 볼 만한 것은 어떤 연결 리스트가 원형 연결 리스트인지 아닌지를 구별해 내는 기능이다.
아래 예제는 리스트가 원형이 아닌자를 판별하는 코드로서 기본적으로 Head로부터 출발하여 계속 다음노드를 따라가면서 다시 Head로 돌아오면 그것은 원형 연결 리스트이고,
마지막에 null을 만나면 원형 연결 리스트가 아니라고 판단할 수 있다.
만약 연결 리스트가 빈 리스트(Empty List)이면, 그것은 원형 연결 리스트라고 정의한다.

*LinkedList.CricularLinkedList.cs IsCircular() 참조

연결 리스트 안의 Cycle 체크

위의 원형 연결 리스트 체크와 비슷한 것으로서, 어떤 연결 리스트 안에 Cycel이 있는지를 체크하는 문제를 살펴보자.
예를 들어, 아래 연결 리스트는 3-4-5-6 구간에서 사이클을 형성하고 있다. 물론 이 연결 리스트는 마지막 노드가 처음 노드를 가리키지 않기 때문에 원형 연결 리스트는 아니다.

*이미지 참조

이렇게 중간에 있는 사이클 혹은 루프를 탐지하기 위해서는, Head에서 출발할 때 두개의 포인터를 사용해서 서로 다른 속도로 이동하면서 두 포인터가 만나는지 체크하면 된다.
예를들어, 첫번째 포인터는 한 노드씩 이동하고, 두번째 포인터는 두 노드씩 이동한다. 이때 만약 중간에 사이클이 있다면, 두 포인터는 서로 다른 속도로 이동하므로
결국에는 어느 싯점에 동일하게 만나게 된다. 이는 마치 원형 운동장을 두명의 선수가 서로 다른 속도로 돌면 결국 한 지점에서 만나는 것과 같은 원리이다.
아래 예제는 이러한 사이클 탐지 방식을 간단히 구현해 본 코드이다.

*LinkedList.CricularLinkedList.cs IsCyclic() 참조


3.5 원형 단일 연결 리스트의 변형

C#의 창시자로서 C#의 아버지라고도 불리우는 앤더스 헤일즈버그는 자신이 좋아하는 자료 구조를 인터뷰에서 소개한 적이 있는데,
그것은 아래와 같이 Head가 마지막 노드를 가리키는 원형 단일 연결 리스트이다.

*이미지 참조

이 리스트의 장점은 새 노드를 추가할 때 바로 Head뒤에 노드를 즉시 추가할 수 있고, 
노드를 검색할 때는 Head의 다음 노드인 첫 노드로 이동하여 바로 일반 연결 리스트처럼 검색할 수 있다는 점이다. 
원형 이중 연결 리스트가 2개의 링크를 계속 관리해야 하는 반면, 이 리스트는 하나의 링크만 관리하고도 O(1)의 성능으로 즉시 새로운 노드를 추가할 수 있다.


3.6 NET의 연결 리스트

닷넷에는 연결 리스트를 지원하는 클래스로 LinkedList<T>가 있다.
이 LinkedList<T> 클래스는 이중 연결 리스트(Doubly Linked List)로 구현되어 있으며, 리스트 노드는 LinkedListNode<T> 클래스를 사용한다.
LinkedList<T>는 개발자가 임의의 타입(T)을 지정할 수 있는 Generic 타입의 이중 연결 리스트이다.
이 LinkedList<T> 클래스는 여러 메서드들을 제공하는데, 예를 들어 노드를 추가하기 위한 메서드로서 AddFirst, AddLast, AddBefore, AddAfter 등의 다양한 메서드가 있어
처음 또는 끝, 혹은 특정 노드의 앞, 뒤에 새 노드를 추가할 수 있다.

아래 코드는 LinkedList<T>의 몇 개의 노드를 추가하고 검색, 출력해 보는 예제이다.

*LinkedList.Example.cs Example4() 참조