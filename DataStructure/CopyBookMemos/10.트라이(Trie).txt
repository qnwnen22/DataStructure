10. 트라이 (Trie)

10.1 Trie 자료구조

Trie는 reTrieval 이라는 단어의 중간 부분을 따온 것으로 Tree와 구분되게 "트라이"라고 발음한다.
트라이는 흔히 Prefix Tree 혹은 Radix Tree라고도 불리우는 정렬된 트리 구조로서 문자열 자동 완성(Auto Complete)이나 스펠링 체크(Spell Checking) 기능 등에서 문자열을 빠르게 인출하는데 유용하게 사용된다.

트라이는 주로 문자열을 키로 사용하는데, 이진 탐색 트리의  경우 각 노드가 키값을 가지고 있어 검색에서 이 노드의 키값을 비교하는 반면 트라이는 문자열 안에 있는 문자 하나 하나가 노드의 링크로 표현되는 트리 구조를 갖는다.
예를 들어 "cat"이라는 단어는 루트노드에서 "c"를 가리키는 자식노드에 연결되고, 다시 "c"노드에서 "a"를 가리키는 자식노드에 연결되고, 계속해서 "a"노드에서 "t"를 가리키는 자식노드에 연결된다.
즉, 이진탐색트리는 한 노드에서 "cat"이라는 문자열을 저장하지만, Trie는 빈 노드인 루트를 포함하여 4개의 노드에 걸쳐 'c','a','t'를 저장한다.

트라이가 26개의 알파벳 문자만을 저장한다고 가정했을 때, 트라이의 노드에 26개의 자식노드 링크를 갖는 배열을 정의하고,
알파벳의 상대적 위치를 찾아 자식노드를 연결할 수 있다.
위의 예에서처럼, 트라이에 "cat"을 저장한다면 루트노드는 배열의 세번째 요소에 'c' 자식노드를 연결하고, 'c' 자식노드에서는 그 배열의 첫번째 요소에 'a' 자식노드를 연결하게 된다.
이러한 방식으로 "cat"을 저장한 후 다시 "cam" 이라는 문자열을 추가한다면, "ca" 는 이미 링크가 연결되어 있으므로 'a' 노드로부터 'm' 만 연결하면 된다.
cat과 cam의 경우 이렇게 ca라는 앞부분(Prefix)을 공유하게 되는데, 이러한 의미에서 Trie를  Prefix Trie라고 부른다.

아래 그림은 몇 개의 단어 (cat,cam,tea,tee,team)를 트라이로 표현한 예이다.
트라이에서 문자열은 루트부터 리프 노드까지 연결되어 표현되지만, 아래 그림에서 tea 문자열과 같이 내부 노드에서 문자열이 완성되는 경우도 있다.
어떤 노드가 문자열의 끝인지를 표현하기 위해, 트라이 노드에서 완성된 문자열인지를 표현하는 Flag 필드를 두거나 노드에 완성된 문자열 자체를 저장하는 등의 방법을 사용할 수 있다.

*이미지 참조

문자열 검색의 성능은 이진 탐색 트리의 경우 전체 노드수가 N이고 트리 내 최대 문자열의 길이가 M 일 때 O(M*log(N))으로 표현할 수 있지만, 트라이의 경우 O(M)의 시간 복잡성을 가지게 된다.
다만, 트라이의 경우 상대적으로 링크를 저장하는 배열 혹은 해시테이블의 공간이 크게 증가하게 된다.


10.2 Trie 구현

단순한 트라이를 표현하기 위해 먼저 트라이가 소문자 알파뱃만을 처리한다고 가정해보자.
이러한 가정 하에 트라이 노드는 아래와 같이 26개의 알파뱃 링크를 갖는 배열과 단어의 끝을 표시하는 플래그를 갖도록 표현할 수 있다.

*Trie.Node.cs 참조

트라이에서 필요한 주요 메서드로는 새로운 문자열을 트라이에 추가하는 Insert() 메서드와 특정 문자열이 트라이 트리에 존재하는지 검색하는 Find() 메서드를 들 수 있다.

Insert() 메서드의 기본 로직은 문자열의 각 문자에 상응하는 자식노드 링크를 추가하거나 이미 있는 경우 해당 자식노드로 이동하면서 문자열의 마지막 문자에 상응하는 노드에 다다르면 EndOfWord 플래그를 true로 설정하는 것이다.

비슷한 방식으로 Find() 메서드의 기본 로직은 문자열의 각 문자에 상응하는 자식노드 링크를 체크해서 상응 링크가 null이면 false를 리턴하고 문자열의 마지막 문자에 상응하는 노드에 다다르면 EndOfWord 플래그를 리턴하면 된다.
이때 EndOfWord는 false일 수도 있는데, 이는 다른 문자열의 부분 문자열이지만 완전한 문자열로 추가되지 않을 수도 있기 때문이다.

아래 예제는 알파벳 문자열을 저장하는 간단한 Trie 클래스를 표현한 코드이다.
아래 SimpleTrie 클래스는 노드 클래스(Node)를 내부 클래스로 포함하고 있으며, 루트노드를 필드로 가지고 있다.

*Trie.SimpleTrie.cs 참조

위에서 구현한 트라이는 소문자 알파벳이라는 제약 조건을 달았는데, 이는 알파벳은 상대적으로 작은 문자셋을 가지고 있기 때문에 고정배열을 적용해 구현하는 것을 보이기 위함이었다.
만약 문자셋이 유니코드와 같이 전세계 언어를 포함해야 하는 경우나 혹은 한글이나 중국어와 같이 상대적으로 많은 문자셋을 가지는 경우, 고정배열을 사용하는 것보다 해시테이블이나 동적배열을 ㅏ용하는 방법을 고려해 볼 수 있다.
특히 해시테이블을 사용하면 유니코드와 같은 광범위한 문자셋에서 대응하는 노드를 쉽게 찾아낼 수 있다.

아래 예제는 유니코드 문자열을 처리하도록 배열 대신 해시테이블을 사용한 Trie, 클래스를 표현한 코드이다.
기본적인 로직은 위 SimpleTrie 클래스와 동일하며, 자식노드를 검색하는 부분을 위치 기반의 배열이 아닌 해시테이블을 사용하고 있다는 점이 차이가 있다.
참고로, C#에서 문자열을 기본적으로 유니코드를 사용한다.

*Trie.Trie.cs 참조


10.3 Trie로 Auto Complete 기능 구현

지금까지 소개한 Trie를 기반으로 Auto Complete 기능을 구현해 보자.
Auto Complete 기능은 사용자가 지금까지 타이핑한 내용을 기반으로 사전이나 데이타베이스에서 그 문자열로 시작되는 단어들을 보여주는 기능이다.
예를 들어, 사전이 "프로", "프로그램", "프로그래밍", "프랑스" 라는 단어가 정의되어 있을 때, 사용자가 "프로그" 라고 치면, "프로그램" 과 "프로그래밍" 이라는 단어 리스트를 표시해 주는 것이다.

Auto Complete 기능을 구현하기 위해서 AutoComplete() 메서드는 List<string> AutoComplete(string prefix) 와 같이 prefix 문자열을 받아 들이고, 단어 리스트를 리턴하게 한다.
AutoComplete() 메서드의 기본 로직은 먼저 루트로부터 prefix 문자열까지의 노드로 이동한 후, 이동한 노드를 기준으로 하는 서브트리를 전위순회하면서 단어 끝으로 표시된 노드인 경우 해당 단어를 결과 리스트에 저장한다.

아래 예제는 위에서 소개한 Trie 클래스 안에 AutoComplete() 메서드를 추가해서 Auto Complete 기능을 구현한 예이다.
AutoComplete() 메서드는 Prefix 노드까지 이동한 후 그 노드부터 Preorder()를 호출한다.
Preorder() 메서드는 노드가 단어 끝으로 표시된 노드인지 체크해서 리스트에 추가한 후 그 노드의 자식노드들(Children)에 대해 다시 순서대로 Preorder()를 재귀 호출 한다.

*Trie.Trie.cs AutoComplete() 메서드 참조

위 예제는 노드간 링크들로부터 단어를 조합하였는데, 단어가 끝나는 노드에 실재 그 단어를 넣어 두면 루트부터 그 노드까지의 단어를 쉽게 알 수 있다.
이를 위해 아래와 같이 Node 클래스에서 단어 문자열을 갖는 Word 속성을 추가할 수 있다.
사실 이 Word 속성이 null 인지 아닌지에 따라 단어 끝인지도 판별할 수 있을 것이므로 EndOfWord 속성을 생략할 수도 있다.

*Trie.Node.cs 참조

위와 같이 약간 변형된 Node 클래스를 사용하면, 완성된 단어를 좀 더 쉽게 가져올 수 있는 AutoComplete() 메서드를 아래와 같이 구현할 수 있다.

*Trie.Trie2.cs 참조