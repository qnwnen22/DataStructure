12. 그래스 (Graph)

12.1 그래프 자료구조

그래프는 비선형 자료구조로서 정점(Vertex)과 간선(Edge)으로 구성되어 있다.
정점은 그래프 노드라고도 하며, 간선은 노드를 연결하는 라인에 해당한다.
그래프는 정점과 간선의 집합으로 정의 되므로, 그래스 G = (V,E)로 표시한다.

트리는 항상 루트노드가 있고 부모와 자식 노드의 관꼐가 명확하지만, 그래프는 루트노드라는 개념이 없고 부모/자식이라는 개념도 없다.
트리가 상하 계층관계를 포현하는 구조라고 한다면, 그래프는 네트워크 모델을 표현하는 구조라 할 수 있다.
또한, 그래프는 트리와 달리 연결이 단절된 부분그래프(Subgraph)들의 집합으로 구성될 수도 있다.

아래는 그래프 구조의 일례를 선보인 것이다.

*이미지 참조

그래프에서 자주 사용되는 용어들을 살펴보면 아래와 같다.

	- 정점(Vertex): 그래프의 노드
	- 간선(Edge): 노드를 연결하는 선
	- 가중치(Weight): 한 정점에서 다른 정점으로 가는 간선에 할당된 비용(cost) 혹은 가중치(weight)
	- 인접 정점(Adjacent Vertex): 한 노드에서 간선에 의해 직접 연결된 이웃 정점
	- 부분그래프(Subgraph): 한 그래프의 부분 영역을 가리키는 것으로 정점(V)과 간선(E) 집합의 부분집합으로 구성된 그래프를 일컫는다.
						  예를 들어, 위 그림에서 1-3-5-7 정점과 이를 연결하는 간선은 위 그래프의 부분그래프가 된다.
	- 방향그래프(Directed Graph): 간선이 방향을 가지고 있는 그래프. 
								줄여서 di-graph 라고함.
	- 무방향그래프(Undirected Graph): 간선이 한방향이 아닌 양방향(bi-directional)으로 갈 수 있는 그래프
	- 차수(Degree): 한 노드에 연결된 인접한 정점들의 수
	- 진입 차수(In-Degree): 방향그래프에서 밖에서 들어 오는 간선의 수
	- 진출 차수(Out-Degree): 방향그래프에서 밖으로 나가는 간선의 수
	- 경로(Path): 간선으로 연결된 정점들을 순서대로 나열한 것
	- 단순 경로: 경로 상에 존재하는 모든 정점이 서로 다른 경로, 즉 정점이 중복되지 않는 경로
	- 경로 길이(Path Length): 경로를 구성하는 데 사용된 간선의 수
	- 순환(Cycle): 시작 노드에서 출발해 다시 그 노드로 돌아오는 경로
	

12.2 그래프의 종류

그래프에는 정점과 간선의 구조 및 연결여부에 따라 다양한 종류의 그래프들이 존재한다.
이들 그래프의 종류들 중 많이 사용되는 것을 들어보면 다음과 같다.

Directed Graph와 Undirected Graph

방향그래프는 유향그래프라고도 불리우는데, 간선이 방향을 가지고 있는 그래프로서 하나의 간선이 한 방향을 가리키는 그래프이다.
무방향그래프는 간선이 방향을 가지고 있지 않은 것으로 양방향으로 이동할 수 있는 그래프이다.	

*이미지 참조

Cyclic Graph와 Acyclic Graph

비순환그래프(Acyclic Graph)는 그래프 내에 사이클이 하나도 없는 그래프를 가리킨다.
이와 반대되는 개념으로 Cyclic Graph 그래프 내에 적어도 하나의 사이클이 있는 그래프를 가리킨다.
Cyclic Graph와 비슷한 용어이지만 다른 의미인 Cycle Graph는 모든 정점이 사이클을 구성하는데 사용되는 그래프로서 정다각형의 그래프이다.
예를 들어, 정삼각형, 정사각형, 정오각형 등의 그래프가 Cycle Graph이다.

*이미지 참조

Connected Graph와 Disconnected Graph

연결그래프(Connected Graph)는 연결되지 않은 정점이 없는 그래프, 즉 모든 정점이 어떤 경로로든 연결되어 있는 그래프를 가리킨다.
한 정점에서 다른 목표 정점으로 어떤 경로로든 도착할 수 있을 때, 두 정점은 연결되어(connected) 있다고 한다.
비연결그래프(Disconnected Graph)는 연결 그래프가 아닌 그래프로서 그래프 정점들 중 하나라도 연결되어 있지 않은 그래프를 가리킨다.

그래프는 연결된 그래프와 연결되지 않은 그래프가 혼합되어 하나의 그래프를 형성할 수 있는데, 이때 연결되어져 있는 부분그래프를 연결 성분(Connected Component) 이라 부른다.
따라서, 비연결그래프(Disconnected Graph)는 두 개 이상의 연결성분(Connected Component)을 갖는 그래프라 할 수 있다.

*이미지 참조

위 연결성분(Connected Component) 그림에서 A,B,C,D 로 연결된 부분그래프가 하나의 연결성분이고, X,Y 로 연결된 그래프가 또 하나의 연결성분이다.

Weighted Graph

가중치 그래프(Weighted Graph)란 간성에 비용이 가중치를 할당한 그래프를 가리킨다.
예를 들어, 항공기 운황로에서 도시 간 거리를 간성위에 표시할 수 있는데 이것이 가중치 그래프이다.

*이미지 참조

Multigraph)

다중 그래프(Multigraph)란 정점 간에 여러 개의 간선을 허용하는 그래프를 가리킨다.

*이미지 참조

방향 비순환 그래프 (Directed Acyclic Graph)

방향 비순환 그래프(DAG)는 그래프 내에 순환(사이클)이 없는 방향그래프를 가리킨다.
방향 비순환 그래프는 순환 반복되는 사이클이 없어서 방향성을 거스리지 않으면서 정점을 나열하는 위상 정렬(Topological Sort)이 가능하다.
방향 비순환 그래프는 주로 위상 정렬을 통해 정점들 간의 선후 관계 혹은 의존 관계를 표현하고 처리하는데 활용된다.
아래 그림은 "셋업 - SetA - App1 - App2" 경로와 "셋업 - SetB - App1 - App2" 경로를 가질 수 있는 DAG 그래프를 표현한 예이다.

*이미지 참조


12.3 그래프의 표현

그래프를 표현하는 방식은 크게 인접 리스트(Adjacency List) 방식과 인접 행렬(Adjacency Matrix) 방식으로 나눌 수 있다.
이러한 두가지 방식 안에서도 그래프 자료구조는 실제로 여러가지 형태로 구현할 수 있기 때문에, 자신의 목적에 맞게 그래프 클래스를 만들어 사용하면 된다.

인접 리스트(Adjacency List)

인접 리스트는 그래프를 표현하는 가장 일반적인 방식으로서, 모든 정점에 대해 그 정점에 인접한 이웃노드들을 리스트로 표현한 것이다.
아래 그림은 인접 리스트의 기본 개념을 표현한 것으로 그래프 정점들의 집합인 정점컬렉션으로부터 각 정점에 연결된 인접 정점들을 리스트로 표현한 것이다.

*이미지 참조

그래프를 인접 리스트로 표현할 때, 그래프의 정점들은 배열이나 동적배열 혹은 해시테이블 등에 저장할 수 있고, 각 정점의 인접한 노드들 혹은 간선들의 정보는 배열, 동적배열, 연결리스트 등에 저장할 수 있다.

아래 예제는 인접 리스트로 그래프를 구현한 한 형태로서, 그래프 정점은 Node<T> 클래스로, 그래프는 Graph<T> 클래스로 표현한 것이다.
먼저 정점을 표현하는 Node<T> 클래스는 노드데이타와 인접하는 이웃 노드들을 동적배열로 관리하고 있다.
또한, Node<T> 클래스는 이웃 노드 배열 이외에 가중치 그래프를 표현하기 위해 Weight 배열을 옵션으로 가질 수 있다.

*Graph.Node1.cs 참조

다음으로 아래는 Graph<T> 클래스로서 기본적으로 그래프를 구성하는 모든 정점들을 갖는 동적배열을 필드(nodes)로 가지고 있으며, 정점과 간선을 추가하는 AddVertex(), AddEdge() 등과 같은 기본 메서드들을 구현하고 있다.

*Graph.Graph1.cs 참조

위 Graph<T> 클래스에서 구현된 메서드들을 좀 더 자세히 설명하면 다음과 같다.

	- Graph 생성자: Graph 생성자는 해당 그래프가 방향그래프(Directed Graph)인지, 무방향그래프(Undirected Graph)인지를 결정하는 파라미터를 받아들인다.
				   directedGraph 파라미터 값이 true 이면 방향그래프이고, false이면 무방향그래프이다.
	
	- AddVertex() 메서드: 새 정점을 추가하는 메서드로서 Graph<T> 클래스 내의 정점 리스트 필드(nodes)에 정점을 추가하는 메서드이다.
	
	- AddEdge() 메서드: 간선을 구성하는 두 정점 from 과 to 노드를 입력받아 from 노드의 Neighbors 리스트에 to 노드를 추가한다.
					   Neighbors 속성은 Node 요소를 갖는 동적 배열로서, 현재 노드에 연결되어 있는 이웃 노드들의 집합을 표현한 것이다.
					   AddEdge() 메서드의 weight 파라미터는 가중치 그래프를 만들기 위한 것으로 간선의 가중치를 설정할 수 있게 한다.
					   가중치 배열(Weights 속성)은 이웃 노드 배열(Neighbors)과 일대일로 매핑되는 것으로, 두 배열의 동일한 인덱스에 있는 요소는 동일한 간선에 대한 정보를 가지고 있다.
					   (주: 참고로 이러한 매핑 방식이 아니라 인접 간선 정보를 담는 별도의 클래스를 만들고 그 클래스가 인접노드와 가중치를 갖도록 정의하면 Neighbors 배열 안에 가중치를 함께 포함할 수 있다.)
					   무방향 그래프이면 from 에서 to 뿐만 아니라 to 에서 from으로도 간선과 가중치를 추가한다.

다양한 인접 리스트 표현

그래프를 인접 리스트(Adjacency List)로 구현하는데에는 여러가지 방식이 있을 수 있는데, 여기서 몇가지 다른 인접 리스트(Adjacency List) 구현 방식에 대해 좀 더 자세히 알아보자.
그래프는 다양한 형태로 구현할 수 있으므로 상황에 따라 가장 정합한 구현 형태를 골라 사용하면 된다.

앞에서 예시한 인접 리스트 예제에서는 Graph 클래스에서 정점들을 저장하기 위해 동적배열을 사용하였는데, 다른 방식으로 정점들을 저장하기 위해 고정배열 혹은 해시테이블 등을 사용할 수도 있다.
또한, Node 클래스에서 인접 노드/간선들을 저장하기 위해 위에서 사용한 동적배열 이외에 고정배열 혹은 연결리스트(Linked List) 등을 사용할 수도 있다.

먼저 다음은 그래프의 정점컬렉션과 각 정점의 이웃 리스트 모두에 고정배열을 사용한 경우이다.
고정배열이므로 그래프객체 초기화시 배열의 크기에 맞게 배열을 생성해야 한다.
이 방식은 그래프의 정점과 간선으 ㅣ수나 혹은 그 최대수를 미리 알고 초기화할 때 사용할 수 있는데, 기초적인 방식이지만 그리 효율적이지는 않다.

*Graph.Node2.cs 참조

다른 표현 방식으로 자주 사용되는 것은 그래프의 정점컬렉션으로 해시테이블을 사용하는 방식이다.
예를 들어, 아래 그림은 정점과 그 정점에 연결된 간선들을 쌍으로 해시테이블에 넣은 구조를 표현한 것으로 해시테이블의 Key에는 정점을 넣고, Value에는 간선들의 연결리스트(Linked List)를 넣은 것이다.

*이미지 참조

또한, 위와 비슷하게 간선들을 연결리스트에 넣는 대신 동적배열에 넣는 경우는 아래와 같이 표현할 수 있다.

*이미지 참조

어떠한 방식을 사용하든 해시테이블을 통해 한 정점에 연결된 인접 리스트를 즉시 엑세스할 수 있다는 점은 동일하다.

아래 예제는 Graph 클래스가 Dictionary<string, List<Node>> 타입의 정점 해시테이블을 가지고 있는데, 이는 정점의 키와 인접 노드 동적배열을 쌍으로 연결한 구조를 표현한 것이다.
만약 동적배열 대신 연결리스트를 사용한다면, 해시테이블 구조를 Dictionary<string, LinkList<Node>> 로 변경하면 된다.

혼히 정점을 문자레이블(string) 혹은 숫자(int)로 표현하곤 하는데, 아래 예제에서 그래프의 정점은 string 타입으로 중복되지 않는 고유 값을 갖는 것을 가정한다.
정점컬렉션을 배열(List<string>)을 사용하는 대신 해시테이블을 사용하면 정점을 신속하게 검색할 수 있는 장점이 있다.

*Graph.Node3.cs 참조

위 예제에서 정점을 추가하는 AddVertex() 메서드는 해시테이블에 이미 해당 정점 Key가 있는지 체크한 후 없으면 새 정점을 추가한다.
새 정점을 추가할 때는 정점에 빈 간선 리스트를 매핑하여 추가한다.
간선을 추가하는 AddEdge() 메서드는 해시테이블에서 시작 정점에 해당하는 인접 간선 리스트를 가져온 후 그 리스트에 새 간선 정보를 추가하면 된다.

마지막으로 또 다른 표현 방식으로, 정점 클래스와 간선 클래스를 각각 정의하고, 정점 클래스의 한 속성이 간선들의 연결리스트를 갖도록 표현하는 방식에 대해 알아보자.
먼저, 정점(Node 클래스)과 간선(Edge 클래스)은 아래와 같이 정의할 수 있다.

*Graph.Node4.cs, Graph.Edge.cs 참조

하나의 정점은 여러 개의 간선들을 가질 수 있으므로 Node 클래스의 EdgeList 속성은 배열 혹은 연결리스트로 표현할 수 있는데, 여기서는 연결리스트로 표현해 보았다.
Edge 클래스는 시작정점(From),도착정점(To)과 가중치(Weight)를 가질 수 있는데, Node 클래스에서 간선들은 그 Node 로부터 연결된 간선들이므로 시작정점은 중복된 데이타가 되므로 경우에 따라 생략할 수도 있다.

위에서 정의된 정점(Node) 클래스와 간선(Edge) 클래스를 이용하여 아래와 같이 Graph 클래스를 정의할 수 있다.
이 Graph 클래스는 Node로 구성된 동적 배열을 가지고 있으며, 각 Node 는 EdgeList 속성을 통해 인접 간선들을 연결리스트로 가지게 된다.

*Graph.Graph4.cs 참조

위에서 정의한 구조를 사용하여 테스트 코드로 실행하면 아래 그림과 같은 인접 리스트가 생성된다.

*이미지 참조

인접 행렬(Adjacency Matrix)

그래프를 표현하는 또 다른 방식으로 인접 행렬 방식이 있다.
인접 행렬은 그래프의 간선 연결관계를 2차원 바열로 나타내는 방식이다.
그래프의 정점들의 수가 |V| 라고 했을 때, 인접행렬의 크기는 |V| * |V| 가 된다.

아래 그림은 무방향그래프와 방향그래프를 인접 행렬로 표현한 예로서, 무방향그래프는 양방향의 간선을 가지므로 대각선을 중심으로 대칭 모양을 하고 있다.
인접 행렬의 2차원 배열을 A 라 했을 때, A[i][j]는 정점 i 에서 정점 j 로 간선을 의미하고, 간선이 있으면 A[i][j] = 1 로 표기하고 간선이 없으면 A[i][j] = 0 으로 표시한다.

*이미지 참조

인접 행렬에서 가중치 그래프를 표현하기 위해서는 배열요소에 0, 1 대신 가중치값을 넣어 사용한다.
아래는 가중치를 갖는 그래프를 인접행렬로 표현한 예이다.

*이미지 참조

그럼 이제 인접행렬이 코드를 사용하여 구체적으로 어떻게 표현되는지 살펴보자.
아래 예제는 인접 행렬을 이용하여 다음과 같은 그래프를 구현한 예이다.

*이미지 참조

아래 예제의 Graph 클래스는 기본적으로 인접행렬을 표현하는 2차원배열을 필드로 가지고 있으며, 필수사항은 아니지만 정점들에 대한 레이블 정보를 담는 배열을 또한 필드로 가지고 있다.
Graph 클래스의 생성자는 정점 레이블들에 대한 정보를 담은 배열과 해당 그래프가 방향그래프인지 무방향그래프인지를 파라미터로 받아들여 그래프를 초기화한다.
Graph 클래스는 간선을 추가하는 AddEdge()와 간선을 제거하는 RemoveEdge() 메서드를 기본적으로 가지고 있으며, 인접행렬을 프린트해보기 위해 DebugPrintGraph() 메서드를 추가하였다.

*Graph.Graph5.cs 참조


12.4 그래프의 탐색

그래프의 정점들을 방문하여 목표 정점을 찾는 것을 그래프의 탐색(Search) 이라 한다.
그래프 탐색은 그래프를 생성, 저장 하는 것과 함께 그래프에서 가장 중요한 연산이라 할 수 있다.
그래프를 탐색하는 방법에는 노드를 방문하는 순서에 따라 깊이 우선 탐색(Depth First Search)과 너비 우선 탐색(Breath First Search)이 있다.

깊이 우선 탐색

깊이 우선 탐색(Depth First Search, DFS)은 자식, 그 자식의 자식 등으로 계속 이동하여 깊은 노드부터 처리하는 방식으로서 각 노드에서 형제 노드를 방문하기 전에 그 자식노드를 먼저 방문하게 된다.
아래는 그래프의 깊이 우선 탐색(DFS)을 표현한 그림이다.
그래프의 시작정점을 A라 했을 때, A는 B,D,E 라는 이웃(자식)노드를 가지고 있는데, 이 중 하나인 B를 방문한 후 B의 형제노드인 D,E를 방문하지 않고 다시 B의 자식노드인 C를 먼저 방문한다.
이렇게 B의 자손을 모두 방문한 후에, B의 형제노드인 D를 방문하고, 계속 이러한 방식으로 나머지 노드들을 방문한다.

*이미지 참조

너비 우선 탐색

너비 우선 탐색(Breath First Search, BFS)은 자신과 가까운 형제 노드부터 처리하는 방식으로서 각 노드에서 자식 노드를 방문하기 전에 형제노드를 먼저 방문하게 된다.
아래는 그래프의 너비 우선 탐색(BFS)을 표현한 그림이다.
그래프의 시작정점을 A라 했을 때, A는 B,D,E 라는 이웃(자식)를 가지고 있는데, 이 중 하나인 B를 방문한 후 B의 형제노드인 D, E를 먼저 방문한다.
다음 B의 자식인 C를 방문하고, E의 자식인 F를 방문한 뒤 F의 형제노드 G를 방문한다.

*이미지 참조

그래프의 특수한 한 형태가 트리(Tree)라고 했을 때, 이진트리의 준위순회(Preorder Traversal), 중위순회(Inorder Traversal), 후위순회(Postorder Traversal)는 너비 우선 순회(Breath First Traversal)에 속하게 된다.
깊이 우선 탐색(DFS)는 엄격한 의미에서는 그래프의 모든 정점을 방문하면서 목표 노드를 검색하는 연산이라면, 깊이 우선 순회(Depth First Traversal)는 이진 트리에서 모든 정점을 방문하는 연산으로 그 차이가 있지만, 흔히 그 유사성 때문에 이 둘을 혼용해서 사용하는 경우가 많다.
또한, DFS는 루트-왼쪽자식-오른쪽자식 등과 같은 특정한 순서를 정하지 않는 넓은 의미의 개념이지만, 그 구현에 있어 전위순회(Preorder Traversal) 방식의 순서를 따르는 경우가 많기 때문에 일부에서는 전위순회와 혼용해서 사용하기도 한다.

깊이 우선 탐색(DFS) 구현

깊이 우선 탐색은 크게 재귀호출을 사용하는 방법과 스택을 사용하는 비재귀호출 방식으로 구현하는 방법이 있다.

그래프의 탐색이 트리의 순회와 특히 다른 점은 그래프의 간선은 트리와 달리 부모-자식 간의 링크 뿐만 아니라 여러 정점들이 무차별적으로 연결될 수 있다는 점이다.
따라서, 그래프의 탐색은 해당 정점을 이미 방문했는지를 체크하는 추가적인 작업이 포함되어야 한다.
정점을 이미 방문했는지 체크하기 위해서는 보통 별도의 테이블을 만들어 방문 노드들을 추가하여 관리하거나 노드(Node) 클래스에 방문 여부를 표시하는 속성을 추가하여 이 속성을 사용하는 방법 등이 있다.
깊이 우선 탐색을 재귀호출로 구현하는 일반적인 방식은 전위순회와 유사한 방식으로 먼저 시작 노드를 방문하고, 그 노드의 인접 노드들 각각에 대해 순차적으로 재귀호출을 수행한다.
단, 그래프의 DFS는 노드를 방문할 때 해당 노드를 방문테이블(visited)에 추가하여 그 노드를 이미 방문했음을 표시하고, 나중에 인접 노드들에 대해 재귀호출을 수행할 때 이미 방문하지 않은 노드만 재귀호출을 수행한다.

아래는 깊이 우선 탐색을 재귀호출로 구현한 예제로서, 앞에서(12.3 그래프의 표현) 소개한 Graph<T> 클래스 안에 DFS() 메서드를 구현한 것이다.
아래 예제에서 DFSRecursive() 메서드가 실제 그래프를 재귀호출로 탐색하는 코드인데, 기본적인 로직은 입력 파라미터로 전달된 노드를 방문하고, 그 노드의 인접 이웃 노드들 중 이미 방문하지 않은 노드들에 대해서 DFSRecursive() 메서드를 다시 재귀호출하는 것이다.

*Graph.Example.Example5() 참조

위 예제에서 사용한 테스트용 그래프는 아래와 같이 2개의 부분 그래프를 갖는 그래프이다.

*이미지 참조

위 예제의 DFS() 메서드는 DSFRecursive() 메서드를 호출하는 메서드인데, DFS() 메서드의 주요 역할은 비연결 그래프가 있는 경우 이들을 모두 포함하여 탐색하도록 하는 기능이다.
연결 그래프의 경우 모든 정점이 연결되어 있으므로 임의의 시작 정점에서 DFSRecursive() 메서드를 한번만 호출하면 되지만, 비연결 그래프의 경우는 임의의 시작 정점에서 한번만 DFSRecursive() 메서드를 호출하면 연결되지 않은 부분 그래프는 탐색되지 않기 때문에, 모든 정점들에 대해 루프를 돌며 방문하지 않은 정점으로부터 다시 DFSRecursive() 메서드를 호출하는 것이다.

깊이 우선 탐색(DFS)를 수행하는 다른 방식으로 비재귀호출(Iterative) 방식으로 스택을 사용하는 방식이 있다.
이 방식의 기본적인 로직은 입력 파라미터로 전달된 시작 노드를 Stack에 넣고, 루프를 돌며 Stack에서 노드를 하나씩 꺼내 방문하면서 그 노드의 인접 노드들 중 이미 방문하지 않은 노드들을 Stack 에 넣는 것이다.
루프는 Stack이 비게 될 때까지 계속 동일한 로직을 수행하게 된다.

아래 예제는 스택을 사용하여 DFS를 수행하는 예이다.
한가지 주목할 점은 이번 예제의 DFS 수행 결과는 A E G F D B C X Y 로서 앞의 재귀호출 방식의 수행 결과 A B C D E F G X Y 와 다른데, 이는 인접 노드들을 스택에 넣는 순서가 서로 다르기 때문이다.
그래프에서 인접 노드들을 방문하는 순서가 특별히 정해져 있는 것이 아니게 때문에 DFS 결과는 여러 가지 루트로 출력될 수 있으므로 이 두가지 결과는 맞는 결과이다.
만약 DFS 수행결과를 재귀호출 방식과 동일하게 하기 위해서는 아래 예제의 포현(A) 대신 포현(B)를 사용하면 된다.

*Graph.Node1<T>.cs DFSUsingStack() 참조

너비 우선 탐색(BFS) 구현

너비 우선 탐색은 트리의 레벨 순서 순회와 유사하게 각 레벨에 있는 인접 노드들을 순차적으로 큐에 넣은 후 이 큐에서 노드를 꺼내 레벨 순서대로 노드를 방문하도록 구현한다.
너비 우선 탐색 역시 DFS와 같이 방문한 노드를 체크하는 방문테이블(visited)을 관리하면서 이미 방문하지 않은 ㄴ노드만 출력하도록 한다.

아래는 너비 우선 탐색(BFS)을 구현한 예제로서, 앞의 Graph<T> 클래스 안에 BFS() 메서드를 구현한 것이다.
아래 예제에서 private BFS(node, visited) 메서드가 실제 그래프를 탐색하는 코드인데, 기본적인 로직은 입력 파라미터로 전달된 시작 노드를 큐에 넣고, 루프를 돌며 큐에서 노드를 하나씩 꺼내 방문하면서 그 노드의 인접 노드들 중 이미 방문하지 않은 노드들을 큐에 넣는 것이다.
루프는 큐가 비게 될 때까지 계속 동일한 로직을 수행하게 된다.
너비 우선 탐색은 이렇게 큐를 통해 인접노드들 즉 형제노드들을 먼저 방문하게 된다.

*Graph.Node1<T>.cs BFS() 참조

위 예제의 public BFs() 메서드는 private BFS(node, visited) 메서드를 호출하는 메서드인데, BFS() 메서드의 주요 역할은, 앞에서 설명한 DFS()와 같이, 비연결 그래프가 있는 경우 이들을 모두 포함하여 탐색하도록 하는 기능이다.


12.5 그래프의 몇가지 알고리즘

지금까지 그래프의 기초 개념 및 구현에 대해 알아 보았다.
여기서는 그래프를 사용하면서 유용하게 사용되는 몇가지 알고리즘을 소개한다.

위상 정렬(Topological Sort)

위상 정렬이란 그래프의 정점들을 전후 관계를 따져 순서대로 정렬하는 것으로서, 방향성 간선을 가지면서 사이클이 없는 방향 비순환 그래프(Directed Acyclic Graph, DAG)에서만 위상정렬을 사용할 수 있다.

아래 그래프는 A부터 F까지의 정점을 갖는 DAG 그래프이다.
방향성 간선은 정점 간의 앞뒤 관계를 표현하는 것으로, 예를 들어 A -> B 가 의미하는 것은 A가 B보다 먼저 수행되어야 하는 것이도, B 는 A 다음으로 수행되어야 한다는 것을 의미한다.

*이미지 참조

위상 정렬은 업무의 일정을 일어나야 할 순서에 따라 배치해야 하는 곳에 주로 활용되는데, 전후 관계나 의존 관계를 따져 정렬해야 하는 곳에 사용된다.
예를 들어, 