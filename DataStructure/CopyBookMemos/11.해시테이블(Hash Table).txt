11. 해시테이블(Hash Table)

11.1 해시테이블 자료구조

해시테이블은 해쉬 맵(Hash Map)이라고도 불리우는데, 키(Key)와 값(Value)을 매핑하는 기능(연관 배열)을 구현한 자료구조이다.
연관 배열(Associative Array)은 Key와 Value)가 서로 연관되어 있는 것을 표현한 추상적 자료형이다.
예를 들어, 아래는 성명을 Key로 하고 그 사람의 전화번호를 Value로 한 해시테이블을 표현한 것이다.

	 [해시테이블]
	Key		Value
	김인수	3643-1932
	박민규	2643-2231
	강민주	2612-3245
	
해시테이블에서 Key와 Value가 갖는 장소를 버켓(Bucket) 혹은 슬롯(Slot)이라 하는데, 이 버켓을 배열로 구현하여 Key와 Value를 매핑하는 테이블을 만들게 된다.

해시테이블에서 Key는 해시 함수(Hash function)를 통해 해시테이블 내의 특정 Bucket 주소로 변환되는데, 이 과정을 해싱(Hashing)이라 한다.
이러한 해싱 과정을 통해 임의의 Key에 상응하는 해시테이블 내의 Bucket 위치를 직접 엑세스할 수 있게 된다.

아래 그림은 간단한 해시테이블의 기초 개념을 표현한 것으로, Key가 해시 함수를 거쳐 Bucket 주소로 변환되고, 해당 Bucket에 Value 값이 들어가 있는 매핑 개념을 표현한 것이다.

*이미지 참조

이상적인 상황에서는 위 그림과 같이 모든 Key가 해시 함수를 거쳐 유일무이한(Unique) Bucket 인덱스에 1 대 1로 매핑될 것이지만, 실제로는 복수 개의 Key들에 대해 해시함수가 동일한 Bucket 인덱스를 리턴할 가능성이 있다.
해시함수가 모든 상황에 완전한 것이 아니기 때문에 복수 Key에 대해 동일한 인덱스를 리턴할 수도 있고, Key의 범위가 상당히 클 경우 완전한 해시 함수라 할지라도 여러 Key들이 동일한 Bucket을 가리킬 가능성도 있다.
이렇게 복수 개의 Key가 동일한 Bucket 주소를 가리키는 것을 해시충돌(Hash Collision)이라 부른다.
이러한 해시충돌 문제를 해결하기 위해 여러 가지 기법들이 사용되는데, 해시테이블을 구현할 때 이러한 해시충돌 부분을 함께 고려하여 구현해야 한다.
위 그림은 해시충돌이 없는 이상적인 상황에서 Key가 해싱을 통해 Value로 1 대 1로 매핑한 것을 표현한 것이지만, 대부분의 경우 해시충돌을 고려하며 Bucket에 Key와 Value를 함께 저장하는 것이 일반적이다.

해시테이블은 삽입, 삭제, 검색 수행에 있어서 평균적으로 O(1)의 시간 복잡성을 가지며, 일반적으로 다른 자료구조에 비해 빠른 성능을 가진다고 알려져 있다.


11.2 해시 함수

해시테이블에서 해싱은 기본적으로 입력된 Key/Value 들을 Bucket 배열에 골고루 분산시키는 것을 그 목표로 한다.
해싱은 개념적으로 해시 함수로부터 리턴된 해시값을 Bucket 배열 크기로 나눈 나머지를 구하는 과정으로 구현되는데, 이러한 과정을 통해 Key는 그에 상응하는 Bucket 인덱스를 가리키게 된다.

hash = hashFunc(key);
index = hash % bucketSize;

해시 함수는 Key에 상응하는 해시값을 리턴하는 함수로서 기본적으로 입력 값에 대해 균일 분포(Uniform distribution)된 해시값을 리턴해야 한다.
만약 해시 함수가 균일하게 분포되지 않은 해시값을 리턴하게 되면, 해시 충돌이 일어날 가능성이 높아지고 따라서 전반적인 해시테이블의 성능이 저하되게 한다.

해시 함수에서 문자열은 ASCII 혹은 유니코드 코드포인트를 사용하여 숫자로 변화하여 처리하는데, 모든 코드포인트를 더하거나 자릿수마다 가중치를 두고 더하는 등 여러 방법을 사용할 수 있다.
해시 함수에는 다양한 종류의 함수들이 나와 있는데, 간단한 해시 함수 몇가지를 소개하면 다음과 같다.

	- Division: 가장 간단한 해시 함수로서 Key를 양의 정수(보통 해시테이블 크기)로 나눈 나머지를 주소로 사용하는 해시 함수이다.
				h(key) = key % size 와 같이 표현할 수 있는데, 이때 size가 소수(Prime number)이면 좋다.
				예를 들어, Key가 34343210, 53465434, 98603210 이고 해시테이블의 크기가 1000일 때, 해시값은 210, 434, 210 이 되어 210에서 충돌이 발생할 수 있다.
	
	- Folding: Key를 여러 부분으로 분할하여 이를 접어서 더하거나 XOR 해서 해시값을 산출하는 방법이다.
			   Folding은 Shift Folding과 Boundary Folding 으로 나뉜다.
				
			   Shift Folding 방법
			   Shift Folding은 숫자를 여러 부분으로 분할하여 분할된 수를 모두 더하는(혹은 덧셈 이외의 다른 계산 방식을 적용) 방법이다.
			   이는 마치 Key가 적힌 종이를 분할하여 찢은 후, 세로로 이동, 정렬하여 더하는 것과 비슷하다.
			   예를 들어, 123456789 라는 Key가 있을 때 이를 3부분으로 나누어 더하면 123 + 456 + 789 = 1368 이 해시값이 된다.

			   Boundary Folding 방법
			   Boundary Folding은 경계를 기준으로 분활된 부분을 교체해가며 역방향으로 수를 읽고 이들을 더하는(혹은 다른 계산법 적용) 방법이다.
			   이는 마치 Key가 적힌 종이를 경꼐를 기준으로 접었을 때, 분할된 부분의 숫자가 정방향, 역방향을 ㅗ교체하는 것과 비슷하다.
			   예를 들어, 123456789 라는 Key가 있을 때 이를 3부분으로 나누면, 123, 456, 789가 되는데, 첫번째 수는 정방향 123, 두번째 수는 역방향 654, 세번째 수는 정방향 789로 하여 이들을 모두 더해 123 + 654 + 789 = 1566 해시값을 산출한다.
			   또는, 역방향/정방향/역방향 방식으로 하여 321 + 456 + 987 = 1764 해시값을 구할 수도 있다.

	- Mid-Squared: Key값을 제곱한 후 중간의 몇자리를 선택하여 해시값으로 사용하는 방법이다.
				   예를 들어, Key가 1234 일 때, 키를 제곱하면 1234 * 1234 = 1522756 이 되고, 여기서 중간 3자리 227을 해시값으로 사용한다.

	- Radix Transformation: Key값을 다른 진법으로 변환하여 해시값으로 사용하는 방법이다.
							예를 들어, 10진법의 Key를 9진법이나 11진법으로 변환하여 해시값을 계산한다.
							Key가 1234 일 때, 이를 9진법으로 변환하면 1621 이 되고, 이를 해시값으로 사용한다.
					

11.3 해시 충돌 (Hash Collision)

해싱에서 복수 개의 Key가 동일한 Bucket 주소를 가리킬 때 해시 충돌이 발생한다.
이러한 해시 충돌을 해결하기 위해 여러 가지 방법이 사용될 수 있는데, 일반적으로 크게 체이닝(Chaining) 방식과 개방 주소법(Open Addressing) 방식을 사용하여 이러한 해시 충돌 문제를 처리한다.

Chaining 방식

해시 충돌 문제를 해결하는 하나의 방식으로 Bucket 안에 하나의 엔트리만 저장하는 것이 아니라 일종의 리스트를 사용하여 하나의 Bucket 인덱스에 여러 개의 엔트리가 연결되어 들어가도록 하는 방법이 있다.
즉, 동일한 Bucket 주소에 복수 개의 인트리 노드가 체인처럼 연결되는 구조로서 이를 Separate Chaining 방식이라 한다.

Separate Chaining 방식에서 가장 일반적인 구조는 Bucket에 연결리스트 노드를 체인처럼 계속해서 연결해 나가는 방식이다.
즉, 특정 인덱스의 Bucket은 첫 연결리스트 노드를 가리키고, 이 노드가 다음 노드를 연결하는 방식을 취한다.
Bucket의 연결 리스트에 새로운 엔트리를 추가하는 방식으로는 맨 마지막에 추가하는 것보다 Bucket 링크의 맨 앞에 삽입하는 방법이 더 효율적이다.
아래 그림은 연결리스트를 사용한 Separate Chaining 방식을 표현한 것이다.

*이미지 참조

Separate Chaining 방식에서 연결리스트를 사용하는 것이 아니라 대안적으로 이진 탐색 트리 혹은 동적 배열 등을 사용할 수도 있다.
이진 탐색 트리를 사용하는 이유는 연결리스트에서 특정 Key를 검색하는데 O(n)의 시간이 걸리기 때문에 이를 O(log n)으로 줄이기 위함인데, 트리 자체를 관리하는 오버헤드가 있다는 단점이 있다.

Open Addressing 방식

개방 주소법(Open Addressing) 방식은 Key에 상응하는 Bucket이 이미 차 있을 때, Bucket 배열을 일정한 간격으로 이동하면서 이용 가능한 다음 Bucket 위치를 찾아 사용하는 방법이다. Chaining 방식에서는 한 Bucket에 여러 엔트리가 들어갈 수 있지만, Open Addressing 방식에서는 한 Bucket 당 하나의 엔트리만 들어갈 수 있다.

Open Addressing 방식으로 다음 Bucket을 찾아가는 방식으로는 다음과 같은 방식들이 있다.

	- 선형 탐사(Linear Probing): 현재 Bucket 위치에서 고정된 크기(보통 1)만큼 다음 위치로 이동하면서 빈 Bucket을 탐사하는 방식
	- 이차 탐사(Quadratic Probing): 현재 Bucket 위치에서 1²(=1), 2²(=4), 3²(=9), ... 만큼씩 이동하면서 빈 Bucket을 탐사하는 방식
	- 이중 해싱(Double Hashing): 해시 함수를 2개 준비하여, 첫번째 해시 함수는 처음 Bucket 해싱에 사용하고, 두번째 해시 함수는 해시 충돌시 다음 Bucket 위치를 계산하는데 사용한다.
								선영 탐사나 이차 탐사의 경우 지정된 간격만큼 이동하는데, 이중 해싱에서는 이 간격을 두번째 해시함수를 써서 산출하게 된다.
								예를 들어, 2개의 해시함수가 h1, h2라 하고 i번째 탐사를 계속한다면, Bucket 위치는 (h1(key)+i*h2(key))%bucketSize 와 같이 계산될 수 있다.

Chaining 방식은 거의 무제한으로 엔트리를 추가할 수 있지만, Open Addressing 방식은 물리적으로 Bucket 배열의 크기만큼만 엔트리를 추가할 수 있다.
실제 사용하는 Key 갯수를 Bucket 배열의 크기로 나눈 값을 Load Factor 라고 하는데, 이 값이 0.7 이상이되면 전체 해시테이블에 성능이 크게 저하될 수 있다.
이 경우 Bucket 배열을 확장하고 기존 엔트리들을 재해싱(Rehashing)하여 확장된 배열에 넣어 주는 방법을 사용할 수 있다.

일반적으로 Open Addressing 방식은 Load Factor가 작고 엔트리의 사이즈가 작은 경우 적합하고, Chaining 방식은 Load Factor가 크고 엔트리 사이즈가 큰 경우 혹은 데이타 크기가 가변적인 경우에 더 적합하다.


11.4 해시테이블 수현