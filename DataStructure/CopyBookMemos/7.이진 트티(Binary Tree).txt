7. 이진 트리(Binary Tree)

7.1 이진 트리 자료구조

트리 중 자식 노드의 수가 2개 이하인 것을 이진 트리라고 한다.
이진 트리는 구현이 단순하다는 점을 비롯하여 여러 장점들을 가지고 있으며, 응용 프로그램에서 다른 트리보다 더 널리 사용되기 때문에 보통 트리를 다룬다고 하면 이진 트리를 다룬다고 보는 경향이 있다.

이진 트리는 각 노드가 최대 2개의 노드를 갖는 트리로서 0개, 1개, 2개의 자식노드를 가질 수 있고, 노드가 아예 없는 경우(empty tree)도 이진 트리로 정의하다.
아래는 이진 트리의 한 예를 선보인 것이다.

*이미지 참조

위와 같은 전형적인 이진트리를 비롯하여 아래와 같이 여러 모양의 이진 트리들이 있을 수 있다.

*이미지 참조

위 그림의 (A)에서와 같이 한쪽 방향으로만 기운 트리를 사향이진트리(Skewrd Binary Tree)라 하고,
(B)에서처럼 가장 밑의 노드들을 제외한 모든 노드들이 양쪽 자식을 모두 가지고 있는 트리를 포화이진트리(Full Binary Tree)라 한다.
그리고 (C)에서처럼 노드가 윗쪽에서부터 아래로 그리고 왼쪽에서부터 오른쪽으로 순서대로 채워져 있는 트리를 완전이진트리(Complete Binary Tree)라 한다.
나중에 소개되는 힙(Heap) 자료구조가 전형적인 완전이진트리에 해당한다.

7.2 연결리스트를 이용한 이진 트리의 구현

이진 트리를 구현하는 방식은 일반적으로 (1)연결리스트를 이용하는 방법과 (2)배열을 이용하는 방법이 있다.

이진 트리의 노드는 데이타와 좌/우 노드를 갖는 간단한 구조이므로 이 노드를 클래스로 정의하고 이를 연결하여 링크를 구성하면 쉽게 이진 트리를 표현할 수 있다.
아래 예제는 간단한 이진 트리 클래스를 정의하고 노드들을 연결하여 이진 트리를 구성한 예이다.

*BinaryTreeNode.cs, BinaryTree.BinaryTree.cs, BinaryTree.Exmaple.cs Exmaple1() 참조

위의 BinaryTreeNode<T> 및 BinaryTree<T> 클래스는 C#의 제네릭 기능을 사용한 클래스로서, 제네릭 크래스는 new BinaryTree<int>()와 같이 객체를 생성할 때 원하는 타입 T(여기서는 int)를 지정하게 된다.

바이너리트리 클래스는 생성자에서 이진 트리의 루트 노드값을 받아들이고 있고, 객체 생성 이후에는 외부에서 루트 노드를 교체할 수 없다.
Root 속성은 private set 으로 설정되어 있는데, 이는 해당 속성이 클래스 내부에서만 설정될 수 있다는 것을 의미한다.

PreorderTraversal() 메서드는 트리 노드들을 순회하는 한 방법으로 Preorder 즉 부모노드를 먼저 순회하고 다음 왼쪽 서브트리를, 마지막으로 오른쪽 서브트리를 순회하는 방식이다.
이 부분에 대해서는 아래에 좀 더 자세히 설명한다.


7.3 배열을 이용한 이진 트리의 구현이

배열을 이용하여 이진 트리를 구현하는 방식은 여러 가지 계산을 필요로 하기 때문에 연결리스트 방식보다 약건 복잡하다고 느낄 수 있지만, 힙과 같은 일부 응용 분야에서는 배열로 구현하는 것이 편리하다.

배열에 이진 트리를 저장하는 방식은 기본적으로 트리 레벨 순으로 왼쪽에서 오른쪽으로 저장하면 된다.
즉, 배열 A의 A[0]에는 루트노드를, A[1]에는 루트의 왼쪽 자식노드를, A[2]에는 루트의 오른쪽 자식노드를 저장한다.
이어 다시 A[3],A[4]에는 A[1]의 자식노드들을 저장하고, A[5],A[6]에는 A[2]의 자식노드들을 저장한다.
고정 배열의 경우, 만약 노드가 없으면 해당 배열 요소를 비워 둔다.

아래 그림은 6개의 노드를 갖는 이진 트리를 배열에 저장한 예이다.

*이미지 참조

이진 트리의 노드들을 체계적으로 배열에 저장하기 때문에, 임의의 노드 즉 임의의 배열 요소 인덱스 i 에서 좌/우 자식노드의 위치는 다음과 같이 계산할 수 있다.

 왼쪽 노드 = 2 * i + 1
 오른쪽 노드 = 2 * i + 2

또한 임의의 배열 요소 인덱스 i 에서 부모노드의 위치는 다음과 같이 계산할 수 있다.

 부모 노드 = (i - 1) / 2

배열로 구현된 이진 트리에서는 이러한 계산을 통해 임의의 노드를 직접 엑세스할 수 있기 때문에 검색 및 추가/삭제에서 O(1)의 시간 복잡도를 갖게 된다.
하지만, 좌우에 비어 있는 노드들이 많은 트리의 경우, 배열에서 사용하지 않는 공간이 늘어난다는 단점이 있다.
예를 들어, 한쪽 방향으로만 기운 사향이진트리를 배열로 저장하면 배열 공간 활용도가 현저하게 낮아지게 된다.
반면, 데이타가 순차적으로 채워져 있는 완전 이진트리의 경우는 거의 모든 배열 공간을 활용하기 때문에 배열로 구현하는 방식이 효율적이다.

아래 예제는 배열을 이용하여 이진 트리를 간단히 구현해 본 코드로서, 임의의 부모노드에서 좌우 자식노드의 데이타를 읽거나 쓰는 메서드(GetLeft, SetLeft 등)와 임의의 노드의 부모 노드 데이타를 가져오는 메서드 (GetParent)등을 구현하였다.

*BinaryTree.BinaryTreeUsingArray.cs, BinaryTree.Exmaple.cs Exmaple2() 참조

참고로 닷넷프레임워크는 트리와 마찬가지로 이진 트리 자료구조를 구현한 클래스를 제공하지 않고 있다.


7.4 이진 트리 순회(Traversal)

트리 순회는 트리 구조에서 각 노드를 정확히 한 번만 체계적인 방법으로 방문하는 과정을 말한다.
배열이나 연결 리스트와 같은 성형 자료 구조에서는 보통 한 가지의 논리적인 순회 방법이 존재하지만, 트리나 그래프 같은 구조에서는 많은 순회 방법이 존재한다.

일반적으로 트리를 순회하는 방법으로는 전위 순회(Preorder Traversal), 중위 순회(Inorder Traversal), 후외 순회(Postorder Traversal), 레벨 순회 순회(Level-order Traversal) 등이 사용된다.

전위 순회는 루트 노드에서 시작해서

 1. 노드를 방문한다.
 2. 왼쪽 서브트리를 전위 순회한다.
 3. 오른쪽 서브트리를 전위 순회한다.
 
준위 순회는 순서를 조금 바꿔서 (1)왼쪽 서브트리를 중쉰 순회 (2) 노드 방문 (3) 오른쪽 서브트리를 중위 순회한다.

후쉬 순회는 (1) 왼쪽 서브트리를 후위 순회 (2) 오른쪽 서브트리를 후위 순회 (3) 노드르 방문하는 순이다.

레벨 순서 순회는 낮은 레벨부터 높은 레벨로 각 레벨을 차례대로 순회한다.

예를 들어, 아래 그림과 같은 이진 트리를 위 4가지 방식으로 순회하면 아래 표와 같은 결과가 나온다.

*이미지 참조

재귀(Recursive) 방식으로 구현한 이진트리 순회

트리 순회는 재귀(Recursive) 호출 혹은 비재귀 반복(Iterative) 방식을 통해 구현할 수 있는데, 재귀 호출로 구현하는 것이 비교적 쉽다.
위의 "연결리스트를 이용한 이진 트리의 구현" 에서 이미 재귀적 전위 순회를 소개하였는데, 비슷한 방식으로 아래와 같이 전위,중위,후위 순회를 구현할 수 있다.

*BinaryTree.BinaryTree.cs 참조

반복(Iterative)방식으로 구현한 이진 트리 순회

반복 방식으로 전위, 중위, 후휘 순회를 구현하기 위해서 보통 스택을 사용하는데,
스택에 나중에 처리할 노드들을 저장해 두었다가 다시 꺼내서 사용하게 된다.

전위 순위를 스택을 사용해서 구현하는 기본 로직은 다음과 같다.

 - 루트 노드를 스택에 넣는다.
 - 스택이 빌 때까지 루프를 돈다
	- 스택에서 Pop하여 노드를 출력한다
	- 오른쪽 노드가 있으면 스택에 저장한다
	- 왼쪽 노드가 있으면  스택에 저장한다

아래 예제는 전위 순회를 스택에 사용하여 구현한 예이다.

*BinaryTree.BinaryTree.cs PreorderIterative() 참조

중위 순회를 스택에 사용하여 구현하는 기본 로직은 다음과 같다.

 - 루트 노드에서 최좌측(Leftmost) 노드까지 스택에 저장한다
 - 스택이 빌 때까지 루프를 돈다
	- 스택에서 Pop하여 노드를 출력한다
	- 오른쪽 노드가 있으면 오른쪽 노드부터 오른쪽 서브트리의 최좌측 노드까지 스택에 저장한다

아래 예제는 중위 순회를 스택을 사용하여 구현한 예로서 위의 기본 로직을 최적화 없이 그대로 구현해 본 것이다.

*BinaryTree.BinaryTree.cs InorderIterative() 참조

위의 중위 순회 예제에서 최좌측 노드까지 스택에 저장하는 부분이 중복되어 있으므로 이러한 중복을 없애고 약간의 최적화를 진행한 코드는 아래와 같다.

*BinaryTree.BinaryTree.cs InorderIterative2() 참조

후위 순회를 스택을 사용하여 구현하는 기본 로직은 다음과 같다.

 - 루트 노드에서 최좌측 노드까지 오른쪽 자식노드와 루트 노드를 스택에 저장한다
 - 스택이 빌 때까지 루프를 돈다
	- 스택에 Pop하여 변수 N에 저장하고, N의 오른쪽 노드가 스택에 Top과 동일한지 체크한다.
	- 동일하지 않으면, 변수 N을 출력한다.
	- 만약 동일하면, 스택에 루트와 오른쪽 노드가 있었다는 의미이다.
	  스택의 Top에 있는 오른쪽 노드를 Pop하고 기존 루트(변수 N)를 다시 스택에 Push 한다.
	  다시 말하면, 스택에 처음 Push할 때 오른쪽 자식노드와 루트 순으로 Push 하였으므로 Pop할 때 루트부터 Pop할 수 있게 되고 
	  이를 통해 스택 상에 루트와 오른쪽 자식 노드가 있는지 판단할 수 있게 된다.
	  이를 통해 오른쪽 서브트리를 처리해야 한다는 것을 판단한 이후에 다시 루트노드를 스택에 Push 하고 오른쪽 서브트리를 처리한다.
	  오른쪽 서브트리를 처리하기 위해서는 다시 오른쪽 서브트리의 루트 노드에서 최좌측 노드까지 오른쪽 자식노드와 루트노드를 스택에 저장하여 동일한 방식으로 반복하여 처리하면 된다.

아래 예제는 후위 순회를 스택을 사횽하여 구현한 예로서 위의 기본 로직을 최적화 없이 그대로 구현해 본 것이다.

*BinaryTree.BinaryTree.cs PostorderIterrative() 참조

위의 예제에서 최좌측 노드까지 스택에 저장하는 부분이 중복되어 있으므로 이러한 중복을 없애고 약간의 최적화를 진행한 코드는 아래와 같다.

*BinaryTree.BinaryTree.cs PostorderIterrative2() 참조

레벨 순서 순회

레벨 순서 순회(Level-order)는 큐를 사용하여 구현하는데, 처음 루트를 큐에 넣은 후 큐에서 하나씩 꺼내 노드를 방문하고 바로 자식노드를 다시 큐에 넣는다.
이러한 방식으로 큐에서 부모 노드를 가져오고 그 자식노드를 큐에 넣으면서 레벨 순서로 노드들을 순회할 수 있다.
아래 코드는 이러한 레벨 순서 순회를 예시한 것이다.

*BinaryTree.BinaryTree.cs LevelorderTraversal() 참조

위의 레벨 순서 순회 코드를 실행하면 출력은 "A B C D E F"이 되는데, 만약 각 레벨별로 한 라인씩 출력하려면 아래와 같이 약간의 수정이 필요하다.
수정된 부분은 각 레벨의 마지막 부분에 "레벨끝"을 표시하는 마크를 큐에 추가하고, 나중에 큐에서 이 레벨끝 마크를 꺼낼 때 새라인으로 이동하고(만약 큐에 데이타가 남아 있으면) 큐에 마지막에 "레벨끝" 마크를 다시 추가하는 것이다.

*BinaryTree.BinaryTree.cs LevelorderNewLine() 참조

위 코드를 실행하면 아래와 같이 출력된다.

A
B C
D E F


7.5 이진 트리 활용 - 수식트리

이진 트리는 여러 다양한 분야에 활용되는데, 수식 처리에도 이진 트리를 활용할 수 있다.
수식트리(Expression Tree)는 수식 계산을 위한 이진 트리로서 루트노드와 내부 노드에는 연산자(Operator)가 있고, 단말(Leaf)노드에는 피연산자(Operand가 있도록 구성된다.

예를 들어, 10 / 4 + 4 * 5 라는 식을 수식트리로 표시하면 아래와 같다.

*이미지 참조

그림에서 보듯이, 수식트리의 단말노드에는 피연산자가 있으며, 루트를 비롯한 내부 노드에는 연산자들로 구성되어 있다.

수식트리 구축

수식으로부터 이진트리를 만들기 위해서흔 보통 후위표기로 된 수식을 사용하여 수식트리를 생성한다.
수식트리를 만드는 기본적인 로직은 다음과 같다.

 - 후위표기로 된 수식 토큰의 끝에서부터 역순으로 토큰을 읽어 나간다.
 - 토큰이 연산자이고 다음 2개의 토큰이 피연산자이면, 연사자를 가진 노드를 만들고 그 오른쪽 자식과 왼쪽 자식에 2개의 피연사자 단말노드를 각각 연결한다.
 - 토튼이 연산자이고 다음 2개의 토큰 중 하나 혹은 둘 다 연산자일 수 있다.
   토큰이 연산자(a)이고 다음 토큰이 다시 연산자(b)이면, 먼저 연산자(a)를 가진 노드를 만들고 그 오른쪽 자식에 연산자(b)를 루트로 보고 생성한 서브트리를 연결한다.
   만약 다음 토큰이 피연산자이면 서브트리 대신 단말(Leaf)노드를 만들어 오른쪽 자식에 연결한다.

아래는 위와 같은 로직을 사용하여 수식트리를 구축하는 예제이다.

*BinaryTree.ExpressionTree.cs 참조

수식트리 계산

수식트리를 구축한 후 이 트리로부터 수식 연산을 수행할 수 있다.
수식트리는 이진트리이므로 루트를 기준으로 왼쪽 서브트리와 오른쪽 서브트리로 나눌 수 있다.
따라서, 왼쪽 서브트리를 계산한 결과와 오른쪽 서브트리 계산한 결과가 재귀호출로 구한 후, 이를 루트 연산자를 사용하여 최종 결과를 구하면 된다.

아래는 재귀호출을 사용하여 수식트리를 계산하는 예제이다.

*BinaryTree.ExpressionTree.cs Evaluate() 참조

수식트리 순회

수식트리는 이진트리와 동일한 방식으로 순회한다.
수식트리를 전위순회하면 전위표기로 된 수식을 산출할 수 있고, 중위순회를 하면 보통 우리가 사용하는 중위표기로 된 수식을 산출한다.
마찬가지로 후휘순회를 하면 컴퓨터에서 사용하는 후위표기 수식을 산출할 수 있다.

특히, 중위표기에서는 괄호를 넣을 필요가 있으므로, 수식트리를 중위순회할 때 루트 혹은 서브트리의 루트가 연산자인지 체크해서 연산자이면 처음에 "(" 을 넣고, 마지막에 ")"을 넣어준다.

아래는 지금까지 설명한 수식트리 전체에 대한 예제인데, 중간 부분에 Inorder(), Postorder() 메서드가 수식트리 순회와 관련된 코드이다.



7.6 이진 트리의 몇가지 알고리즘

이진 트리를 사용하면서 유용하게 사용되는 몇가지 알고리즘을 소개한다.

이진 트리 깊이(Depth)구하기

이진 트리는 하나의 루트 노드와 왼쪽 자식 노드를 중심으로 한 왼쪽 서브트리, 그리고 오른쪽 자식 노드를 중심으로 한 오른쪽 서브트리로 구성되어 있다.

이진 트리의 최대 깊이를 구하기 위해서는 왼쪽 서브트라니 오른쪽 서브트리 중 더 큰 깊이를 가진 서브트리의 깊이를 구한 후, 루트 노드와 서브트리의 깊이인 1을 더하면 된다.
이때 좌우 서브트리의 깊이는 다시 재귀 호출 방식으로 각 서브트리의 최대 깊이를 구하면 된다.

아래는 이러한 재귀 호출 방식으로 트리의 최대 깊이를 구한 예제이다.

*BinaryTree.BinaryTree.cs GetMaxDeplth() 참조

트리의 깊이(Tree Depth)는 루트 노드에서 가장 먼 거리에 있는 Leaf 노드와의 길이를 구하는 것인데, 이는 다시 말하면 루트와 가장 멀리 있는 Leaf 노드 간의 간선(Edge)의 수에 해당된다.
위 코드에서 트리 깊이를 (노드의 수가 아닌) 간선의 수로 계산하기 위해 node가 null일 때 -1을 리턴하였다.
이러한 계산에 의하면, 노드가 아예 없는 빈 트리의 경우는 깊이가 -1이 되고, 루트 노드 하나만 있는 경우 깊이는 0이 된다.

이진 트리 노드 수 구하기

이진 트리가 몇 개의 노드를 가지고 있는지 세는 Count() 메서드는 노드 전체를 순회하면서 구할 수도 있지만, 아래 예제와 같이 재귀 호출을 통해서도 쉽게 구할 수 있다.
즉, 이진 트리를 루트와 좌우 서브트리로 분류하고, 루트노드 하나와 재귀 호출을 사용하여 왼쪽 서브트리의 카운트와 오른쪽 서브트리의 카운트를 모두 더하면 된다.

*BinaryTree.BinaryTree.cs Count() 참조

이진 트리에서 노드 경로 찾기

이진 트리에서 루트부터 특정 노드까지의 경로를 찾기 위해서는 먼저 검색 영역을 루트 노드와 좌우 서브트리로 구분하고 재귀 호출을 통해 경로를 검색할 수 있다.
경로 찾기 메서드는 검색경로를 저장하기 위해 입력 파라미터에 레퍼런스 타입의 배열(혹은 스택)을 전달하고, 검색한 노드를 찾았는지를 표시하는 bool값을 리턴하도록 한다.

검색의 기본적인 로직은
(1) 트리 혹은 서브트리의 루트 노드를 경로 배열에 추가한다.
(2) 트리 혹은 서브트리의 루트 노드가 검색 노드인지 체크하고 맞으면 true를 리턴한다.
(3) 재귀 호출을 사용하여 왼쪽 서브트리에서 검색 노드를 탐색하고 맞으면 true를 리턴한다. 
    다음 다시 재귀 호출을 사용하여 오른쪽 서브트리에서 검색 노드를 탐색하고 맞으면 true를 리턴한다.
(4) 위 (2),(3) 경우가 실패하였으면 경로 배열에서 (1)에서 추가한 루트 노드를 제거하고 false를 리턴한다.

아래는 위의 기본 로직을 사용하여 루트부터 특정 노드까지의 경로를 검색하는 예제이다.

*BinaryTree.BinaryTree.cs FindTreePath() 참조

최소 공통 조상(Lowest Common Ancestor) 구하기

최소 공통 조상(LCA)이란 트리 구조에서 임의의 두 노드를 지정했을 때 두 노드를 포함하는 가장 가까운 공통의 부모를 말한다.
예를 들어, 아래 그림에서 노드 D와 G의 최소 공통 조상은 노드 B가 되고, D와 C의 최소 공통 조상은 A가 되며, C와 F의 최소 공통 조상은 C가 된다.

*이미지 참조

최소 공통 조상을 구하는 것은 두 노드 간의 거리를 구하는데 유용하게 사용되는데, 두 노드 간의 거리는 (루트와 노드1 간의 거리) + (루트와 노드2 간의 거리) - (2 * 루트와 LCA 간의 거리)로 계산된다.

최소 공통 조상을 구하는 한 방법으로 위에서 구현한 특정 노드 경로 찾기를 이요할 수 있다.
즉, 두 노드의 경로를 구한 후 앞에서부터 동일한 경로 부분을 알아내면 이것이 최소 공통 조상이 된다.
이러한 방식은 보통 트리를 두 번 순회하여야 하고, 별도의 경로 저장 공간이 필요하다는 단점이 있다.
아래는 이러한 경로 찾기 방식을 사용한 예제이다.

*나중에 작성

최소 공통 조상을 구하는데 좀 더 효율적인 방법으로 재귀 호출을 해가며 한번의 트리 순회로 LCA를 찾는 방법이 있다.
이러한 방법은 트리를 루트 노드와 왼쪽 서브트리, 오른쪽 서브트리로 구분하고, (1) 루트 노드가 임의의 두 노드(a,b)와 같으면 해당 루트 노드가 LCA 노드가 되고, (2) 같지 않으면 왼쪽과 오른쪽 서브트리에서 각각 CAL를 재귀 호출하고 두 노두(a,b)와 같으면 해당 루트 노드가 LCA 노드가 되는 것이다.
만약 왼쪽이나 오른쪽 서브트리 어느 한쪽에만 두 노드가 있으면 한쪽 서브트리를 재귀 호출 하여 계속 위의 (1),(2) 조건에 맞는 공통 조상을 찾아 나간다.

아래 예제는 두 노드가 트리안에 존재한다는 가정하에 위와 같은 재귀 호출 방법으로 구현한 코드이다.

*BinaryTree.BinaryTree.cs LeastCommonAncestor() 참조

