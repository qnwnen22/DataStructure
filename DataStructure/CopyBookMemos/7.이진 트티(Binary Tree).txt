7. 이진 트리(Binary Tree)

7.1 이진 트리 자료구조

트리 중 자식 노드의 수가 2개 이하인 것을 이진 트리라고 한다.
이진 트리는 구현이 단순하다는 점을 비롯하여 여러 장점들을 가지고 있으며, 응용 프로그램에서 다른 트리보다 더 널리 사용되기 때문에 보통 트리를 다룬다고 하면 이진 트리를 다룬다고 보는 경향이 있다.

이진 트리는 각 노드가 최대 2개의 노드를 갖는 트리로서 0개, 1개, 2개의 자식노드를 가질 수 있고, 노드가 아예 없는 경우(empty tree)도 이진 트리로 정의하다.
아래는 이진 트리의 한 예를 선보인 것이다.

*이미지 참조

위와 같은 전형적인 이진트리를 비롯하여 아래와 같이 여러 모양의 이진 트리들이 있을 수 있다.

*이미지 참조

위 그림의 (A)에서와 같이 한쪽 방향으로만 기운 트리를 사향이진트리(Skewrd Binary Tree)라 하고,
(B)에서처럼 가장 밑의 노드들을 제외한 모든 노드들이 양쪽 자식을 모두 가지고 있는 트리를 포화이진트리(Full Binary Tree)라 한다.
그리고 (C)에서처럼 노드가 윗쪽에서부터 아래로 그리고 왼쪽에서부터 오른쪽으로 순서대로 채워져 있는 트리를 완전이진트리(Complete Binary Tree)라 한다.
나중에 소개되는 힙(Heap) 자료구조가 전형적인 완전이진트리에 해당한다.

7.2 연결리스트를 이용한 이진 트리의 구현

이진 트리를 구현하는 방식은 일반적으로 (1)연결리스트를 이용하는 방법과 (2)배열을 이용하는 방법이 있다.

이진 트리의 노드는 데이타와 좌/우 노드를 갖는 간단한 구조이므로 이 노드를 클래스로 정의하고 이를 연결하여 링크를 구성하면 쉽게 이진 트리를 표현할 수 있다.
아래 예제는 간단한 이진 트리 클래스를 정의하고 노드들을 연결하여 이진 트리를 구성한 예이다.

*BinaryTreeNode.cs, BinaryTree.BinaryTree.cs, BinaryTree.Exmaple.cs Exmaple1() 참조

위의 BinaryTreeNode<T> 및 BinaryTree<T> 클래스는 C#의 제네릭 기능을 사용한 클래스로서, 제네릭 크래스는 new BinaryTree<int>()와 같이 객체를 생성할 때 원하는 타입 T(여기서는 int)를 지정하게 된다.

바이너리트리 클래스는 생성자에서 이진 트리의 루트 노드값을 받아들이고 있고, 객체 생성 이후에는 외부에서 루트 노드를 교체할 수 없다.
Root 속성은 private set 으로 설정되어 있는데, 이는 해당 속성이 클래스 내부에서만 설정될 수 있다는 것을 의미한다.

PreorderTraversal() 메서드는 트리 노드들을 순회하는 한 방법으로 Preorder 즉 부모노드를 먼저 순회하고 다음 왼쪽 서브트리를, 마지막으로 오른쪽 서브트리를 순회하는 방식이다.
이 부분에 대해서는 아래에 좀 더 자세히 설명한다.


7.3 배열을 이용한 이진 트리의 구현이

배열을 이용하여 이진 트리를 구현하는 방식은 여러 가지 계산을 필요로 하기 때문에 연결리스트 방식보다 약건 복잡하다고 느낄 수 있지만, 힙과 같은 일부 응용 분야에서는 배열로 구현하는 것이 편리하다.

배열에 이진 트리를 저장하는 방식은 기본적으로 트리 레벨 순으로 왼쪽에서 오른쪽으로 저장하면 된다.
즉, 배열 A의 A[0]에는 루트노드를, A[1]에는 루트의 왼쪽 자식노드를, A[2]에는 루트의 오른쪽 자식노드를 저장한다.
이어 다시 A[3],A[4]에는 A[1]의 자식노드들을 저장하고, A[5],A[6]에는 A[2]의 자식노드들을 저장한다.
고정 배열의 경우, 만약 노드가 없으면 해당 배열 요소를 비워 둔다.

아래 그림은 6개의 노드를 갖는 이진 트리를 배열에 저장한 예이다.

*이미지 참조

이진 트리의 노드들을 체계적으로 배열에 저장하기 때문에, 임의의 노드 즉 임의의 배열 요소 인덱스 i 에서 좌/우 자식노드의 위치는 다음과 같이 계산할 수 있다.

 왼쪽 노드 = 2 * i + 1
 오른쪽 노드 = 2 * i + 2

또한 임의의 배열 요소 인덱스 i 에서 부모노드의 위치는 다음과 같이 계산할 수 있다.

 부모 노드 = (i - 1) / 2

배열로 구현된 이진 트리에서는 이러한 계산을 통해 임의의 노드를 직접 엑세스할 수 있기 때문에 검색 및 추가/삭제에서 O(1)의 시간 복잡도를 갖게 된다.
하지만, 좌우에 비어 있는 노드들이 많은 트리의 경우, 배열에서 사용하지 않는 공간이 늘어난다는 단점이 있다.
예를 들어, 한쪽 방향으로만 기운 사향이진트리를 배열로 저장하면 배열 공간 활용도가 현저하게 낮아지게 된다.
반면, 데이타가 순차적으로 채워져 있는 완전 이진트리의 경우는 거의 모든 배열 공간을 활용하기 때문에 배열로 구현하는 방식이 효율적이다.

아래 예제는 배열을 이용하여 이진 트리를 간단히 구현해 본 코드로서, 임의의 부모노드에서 좌우 자식노드의 데이타를 읽거나 쓰는 메서드(GetLeft, SetLeft 등)와 임의의 노드의 부모 노드 데이타를 가져오는 메서드 (GetParent)등을 구현하였다.

*BinaryTree.BinaryTreeUsingArray.cs, BinaryTree.Exmaple.cs Exmaple2() 참조

참고로 닷넷프레임워크는 트리와 마찬가지로 이진 트리 자료구조를 구현한 클래스를 제공하지 않고 있다.


7.4 이진 트리 순회(Traversal)

트리 순회는 트리 구조에서 각 노드를 정확히 한 번만 체계적인 방법으로 방문하는 과정을 말한다.
배열이나 연결 리스트와 같은 성형 자료 구조에서는 보통 한 가지의 논리적인 순회 방법이 존재하지만, 트리나 그래프 같은 구조에서는 많은 순회 방법이 존재한다.

일반적으로 트리를 순회하는 방법으로는 전위 순회(Preorder Traversal), 중위 순회(Inorder Traversal), 후외 순회(Postorder Traversal), 레벨 순회 순회(Level-order Traversal) 등이 사용된다.

전위 순회는 루트 노드에서 시작해서

 1. 노드를 방문한다.
 2. 왼쪽 서브트리를 전위 순회한다.
 3. 오른쪽 서브트리를 전위 순회한다.
 
준위 순회는 순서를 조금 바꿔서 (1)왼쪽 서브트리를 중쉰 순회 (2) 노드 방문 (3) 오른쪽 서브트리를 중위 순회한다.

후쉬 순회는 (1) 왼쪽 서브트리를 후위 순회 (2) 오른쪽 서브트리를 후위 순회 (3) 노드르 방문하는 순이다.

레벨 순서 순회는 낮은 레벨부터 높은 레벨로 각 레벨을 차례대로 순회한다.

예를 들어, 아래 그림과 같은 이진 트리를 위 4가지 방식으로 순회하면 아래 표와 같은 결과가 나온다.

*이미지 참조

재귀(Recursive) 방식으로 구현한 이진트리 순회

트리 순회는 재귀(Recursive) 호출 혹은 비재귀 반복(Iterative) 방식을 통해 구현할 수 있는데, 재귀 호출로 구현하는 것이 비교적 쉽다.
위의 "연결리스트를 이용한 이진 트리의 구현" 에서 이미 재귀적 전위 순회를 소개하였는데, 비슷한 방식으로 아래와 같이 전위,중위,후위 순회를 구현할 수 있다.

*BinaryTree.BinaryTree.cs 참조

반복 방식으로 구현한 이진 트리 순회

반복 방식으로 전위,중위,후위 순회를 구현하기 위해서는 보통 스택을 사용하는데, 스택에 나중에 처리할 노드들을 저장해 두었다가 다시 꺼내서 사용하게 된다.

전위 순회를 스택을 사용하여 구현하는 기본 로직은 다음과 같다.

 - 루트 노드를 스택에 넣는다.
 - 스택이 빌 때까지 루프를 돈다.
	- 스택에 Pop하여 노드를 출력한다
	- 오른쪽 노드가 있으면 스택에 저장한다
	- 왼쪽 노드가 있으면 스택에 저장한다

아래 예제는 전위 순회를 스택을 사용하여 구현한 예이다.

*BinaryTree.BinaryTree.cs PreorderIterative() 참조
