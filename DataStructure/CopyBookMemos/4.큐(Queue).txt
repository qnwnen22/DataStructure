4. 큐(Queue)

4.1 Queue 자료구조
큐는 도착한 순서대로 데이타를 꺼내서 사용하는 선형적인 자료구조이다.
큐는 흔히 FIFO(First In First Out)이라고 불리우는 자료구조로서 먼저 저장된 것이 먼저 꺼내지는 선입선출 구조를 가지고 있다.
만약 즉시 처리하지 않아도 되는 일이라면, 큐에 차례로 넣어 두고 순서대로 그 일들을 처리할 때 큐를 사용하곤 한다.

*이미지 참조

큐는, 위 그림에서 보듯이, 뒤(리어,Rear)에서 데이타를 추가하고 앞(프론트,Front)에서 데이타를 읽는 구조를 갖는다.
큐는 흔히 배열(Array)이나 연결 리스트(Linked List)를 사용하여 구현하곤 한다.


4.2 배열로 구현한 Queue

고정 배열을 사용한 Queue구현

배열을 사용하며 큐를 구현하기 가장 산순한 구현은 고정된 배열을 할당하고 프론트나 리어 인덱스를 관리하면서 큐를 구현하는 방식이다.
배열에 새 데이타를 추가할 때는 리어 인덱스가 가리키는 배열요소에 데이타를 넣고, 데이타를 읽으며 제거할 때는 프론트 인덱스가 있는 배열요소를 제거한다.

프론트에서 배열요소를 제거할 때는 프론트 인덱스를 프론트 다음 요소로 이동하는 방식을 사용하거나 또는 모든 배열요소를 프론트 앞으로 땡겨 옮기는 방식을 사용할 수 있다.

첫번째 방식은 리어 인덱스가 고정 배열 크기만큼 이동하면 더 이상 큐에 데이타를 넣을 수 없으며, 프론트 인덱스가 계속 이동하여 최대 고정 배열 크기만큼만 이동할 수 있다.
즉, 큐에 저장할 수 있는 최대 데이타수가 배열 크기와 같게 된다.

두번째 방식, 즉 프론트가 제거될 때마다 배열요소를 모두 앞으로 땡기는 방식은 제거된 요소들만큼 계속 데이타를 넣을 수 있는 장점이 있지만 큐에서 데이타를 꺼낼 때마다
배열요소들을 모두 옮겨야 하기 때문에 성능면에서 좋지 않은 방식이다.

고정 배열로 큐를 구현할 때 발생하는 이러한 문제들은 아래 소개하는 원형 배열을 이용함으로써 해결될 수 있다.

원형 배열을 사용한 큐 구현

배열을 사용하여 큐를 구현할 때 고정배열이 갖는 문제점들을 해결하기 위해 흔히 원형 배열을 사용한다.
고정된 크기의 배열에서 프론트 인덱스가 가리키는 요소를 읽고 인덱스를 계속 다음 요소로 이동해 가면  금새 마지막 배열요소에다다르게 되고 더이상 데이타를 추가할 수 없게 된다.
즉 프론트 인덱스가 마지막 요소에 이르렀을 때 데이타를 추가할 수 있는 공간은 앞에 모두 비어 있는데도 실제 데이타를 추가할 수 없게 되는 것이다.
이러한 문제점을 해결하기 위해 원형 배열을 사용할 수 있다.
즉, 마지막 배열 요소에서 첫 요소로 이동할 수 있는 원형 배열을 사용하면 비어 있는 공간을 효율적으로 재사용할 수 있는 큐를 구현할 수 있다.
물론 원형 배열이라도 모든 요소가 차게 된다면 더이상 큐에 데이타를 넣을 수 없게 되는데, 이를 위해 원형 배열을 동적으로 확장 하는 원형 동적 배열의 구현을 생각해 볼 수 있다.

큐를 구현하는 원형 배열은 데이타를 읽기 위한 포인터로서 프론트 배열 인덱스를 가지며, 데이타를 추가하기 위한 포인터로서 리어 인덱스를 갖는다.

예를 들어, 아래 그림에서 A[1]이 큐 데이타를 읽는 시작점이므로 프론트 인덱스는 1이되고, A[4]는 큐 마지막 요소를 가리키며 그 다음 요소에 새 데이타를 추가할 수 있게 하는
리어 인덱스는 4가 된다.
(주: 리어 인덱스는 큐 구현 방법에 따라 큐의 마지막 요소를 가리키거나 혹은 마지막 요소의 다음 요소 즉 새 데이타가 추가 되는 위치를 가리킬 수 있다.)

*이미지 참조

원형배열은 배열을 순환하는 구조로 만들어야 하므로, 프론트/리어를 위한 배열 인덱스를 증가시킬 때 mod연산자를 사용하여 배열의 마지막에 도착했을 때 첫 배열 인덱스를 돌아오게 한다.

C#에서 mod 연산자는 % 로서 나머지를 구할 때 사용되는데, 예를 들어 10 % 8 은 10을 8로 나눈 나머지 즉 2가 된다.
이렇게 mod 연산자를 사용하여 프론트(혹은 리어) 포인터의 증가를 표현하면 다음과 같이 표현할 수 있다.

	Front = (Front + 1) % A.Length;
	
위 표현식을 사용하여, A[7] 요소를 읽고 다음 요소로 프론트 포인터를 이동한다면, (7 + 1) % 8 = 0 즉 배열 0번 요소로 이동하게 된다.

큐를 구현하는 기본 과정을 살펴보면 다음과 같다.

	1. 큐의 초기 상태에서 프론트와 리어 인덱스는 -1 로 설정한다
	2. 큐에 데이타를 처음 추가할 때, A[0]에 넣고 프론트와 리어는 0이 된다.
	3. 큐에 데이타를 추가(Enqueue)할 때, 큐가 가득 찬 상태인지 체크하고, 가득 차지 않았으면 다음 위치 즉(Rear + 1) % A.Length 위치로 이동하여 데이타를 넣는다.
	   가득 찬 경우(a) 에러를 발생시키거나, (b) 배열을 확장하여 데이타를 추가할 수 있게 한다.
	   큐가 가득 찬 상태인지를 체크하는 방법은 리어의 다음 인덱스가 프론트와 같은지 체크하면 되는데, 식으로는(Rear + 1) % A.Length == Front 와 같이 표현할 수 있다.
    4. 큐에서 데이타를 읽어 제거(Dequeue)할 때는, 먼저 큐가 비어 있는지 체크하고, 비어 있지 않으면 데이타를 읽고 프론트를 하나 증가시킨다.
	   프론트의 증가는 식으로 Front = (Front + 1) % A.Length 와 같이 표현할 수 있다.
	   큐에서 마지막 요소를 읽어 낼 때, 즉 프론트와 리어가 같을 때, 데이타를 읽어낸 후 프론트와 리어를 -1로 표시한다.
	   이는 초기 상태의 프론트와 리어가 -1이었던 것과 같은 상태인데, 큐가 비어 있다는 것을 의미하며, 여기서 -1은 Empty를 표현하는 특별한 값으로 볼 수 있다.
	   위와 같은 구현에서 큐가 비어 있는지 체크하는 방법은 프론트가 리어가 모두 -1 인지를 체크하면 된다.
	   
아래 예제는 원형배열을 사용하기 간단한 큐를 구현한 것으로 여기서는 배열을 확장하는 기능을 추가하지 않았다.
배열을 확장하는 기능을 추가하기 위해서는 Enqueue() 메서드에서 큐가 가득 찼을 때, 배열을 확장한 후 기존 배열 데이타를 확장된 배열로 이전하면 된다.

*Queue.QueueUsingCircularArray.cs 참조

큐의 가장 기본적인 메서드는 데이타를 추가한은 Enqueue()와 데이타를 읽어 내는 Dequeue()이다.
Enqueue()의 경우 데이타를 추가하기 전에 큐가 가득 차 있는지 체크하고, Dequeue()의 경우 데이타를 읽기 전에 큐가 비어 있는지를 체크해야 한다.

원형 배열 큐와 다른 방식의 구현

위와는 좀 다른 구현 방법으로 리어를 새 데이타가 삽입되는 위치로 설정하고, 리어의 다음 위치가 프론트와 같으면 데이타를 추가하지 않고 큐가 가득 찬 상태(Full)로 정의하는 방식이 있다.
그림으로 나타내면 아래와 같이 표현할 수 있다.
위 방식과 다른 점은 리어 포인터가 이미 추가된 배열요소의 마지막에 있는 것이 아니라 마지막 요소 바로 다음 인덱스를 가리키고 있다는 점이다.

*이미지 참조

이 방식은 전체 배열에서 1개를 뺀 숫자만큼만 데이타를 넣을 수 있는 단점이 있지만, 프론트와 리어가 같으면 큐가 Empty 상태임을 쉽게 정의할 수 있는 장점이 있다.
즉, 앞에서와 같이 -1이라는 특별한 값을 사용할 필요가 없다.
배열에 추가할 공간이 1개 남았을 때, 즉 리어의 다음 위치가 프론트와 같을 때, 데이타를 채우고 Rear+1 으로 이동하게 되면 프론트와 리어가 같게 되는데,
그러면 큐가 Empty인지 Full인지 구별할 수 없게 된다. 따라서, 리어의 다음 위치가 프론트와 같으면 데이타를 추가하지 않고 Full 이라고 정의하는 것이다.

*이미지 참조

또한, 아래 그림은 큐가 빈 상태를 표현할 것으로 큐에 데이타가 1개 남았을 때 Dequeue를 하면 프론트 인덱스와 리어 인덱스가 같게 되어 Empty 상태가 된다.

아래 예제를 이러한 방식으로 구현한 샘플 코드이다.

*Queue.QueueUsingCircularArray2.cs 참조

배열을 사용하여 큐를 구현하는 또 다른 접근 방법으로 count라는 필드를 두고 인큐(Enqueue)와 디큐(Dequeue) 시에 count를 증감하는 방법이 있다.
이 방식은 큐가 가득 찬 상태와 빈 상태를 쉽게 체크할 수 있으며 또한 현재 큐에 들어 있는 데이타 수를 쉽게 알 수 있다는 장점이 있다.
만약 카운트가 0 이면 큐가 빈 상태를 의미하며, 카운트가 큐의 크기와 동일하다면 큐가 가득 찬 상태라는 것을 알 수 있다.
아래 예제를 이러한 방식을 구현한 코드이다.

*Queue.QueueUsingCircularArray3.cs 참조


