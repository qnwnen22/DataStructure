2.1 배열의 기초개념

배열은 연속적인 메모리 상에 동일한 데이타 타입의 요소들을 순차적으로 일렬로 저장하는 자료구조이다.
순차적으로 나열된 배열요소는 각 요소마다 인덱스를 붙이는데, 
예를들어, 배열을 A라 했을 경우 첫번째 배열요소는 A[0], 두번째 배열요소는 A[1], 세번째 배열요소는 A[2] 등으로 배열 인덱스를 붙인다.

하나의 배열은 고정된 크기를 가지며, 배열 인덱스를 사용할 경우 각 배열요소를 즉시 엑세스할 수 있다.
예를 들어, 배열 A가 100개의 배열요소가 있을 때, A[0], A[50], A[99] 등을 엑세스하는 시간은 동일하며,
모두 해당 요소를 즉시 엑세스하여 배열요소 값을 읽거나 쓸 수 있다.

배열은 거의 대부분의 프로래밍 언어에서 사용할 수 있는 가장 기초적인 자료구조로서, C# 프로그래밍 언어도 물론 배열을 기본적으로 지원한다.
(C/C++에서의 배열이 연속적인 메모리 공간에 대한 주소를 의미한다면, C#에서의 배열은 배열 객체로서 메모리상의 배열에 대한 정보를 가지며
 System.Array 클래스로부터 생성되어 System.Array 클래스의 속성과 메서드를 사용할 수 있는 객체 인스턴스이다.)
 
배열의 차원(Dimension)

배열의 차원(Dimension)이란 한 배열요소를 선택하기 위해 사용하는 인덱스의 수이다.

배열 A의 배열 요소가 10개이고 이를 메모리 상에 일렬로 저장하면 아래와 같이 표현할 수 있다.
각 요소는 0부터 시작하는 배열 인덱스를 갖는데, 예를 들어 배열 A의 첫번째 배열요소는 A[0] 이고, 두번째 요소는 A[1]으로 표현한다.
(주:이렇게 배열 인덱스가 0부터 시작하는 것을 Zero-based Indexing이라 부른다.
 인덱스는 0(Zero-based Indexing), 1(One-based Indexing), 또는 n(n-based Indexing) 부터 시작할 수 있는데,
 많은 프로그래밍 언어가 Zero-based Indexing을 사용한다)
 
					int[] A = new int[10];
	A[0] | A[1] | A[2] | A[3] | A[4] | A[6] | A[7] | A[8] | A[9]
	 15  |  2	|  8   |  19  |	 5	 |  20	|  9   |  32  |  4

위 그림과 같이, 한 줄로 쭉 연결된 배열을 1차원 배열이라 하며, 배열 요소를 선택할 때 1개의 인덱스만 필요하다.
반면, 2차원 배열은 아래 그림과 같이 행(row)과 열(column)을 갖는 배열을 의미하는데, 예를들어,
아래는 3개의 행과 4개의 열을 갖는 2차원 배열이며, 배열 요소를 선택하기 위해 행과 열 2개의 인덱스가 필요하다.

					int[,] A = new int[3,4];
				A[0,0] | A[0,1] | A[0,2] | A[0,3]
				A[1,0] | A[1,1] | A[1,2] | A[1,3]
				A[2,0] | A[2,0] | A[2,2] | A[2,3]

C#은 1차원 배열을 비롯한 2차원, 3차원, ... 32차원 배열까지 지원한다.


2.2 가변 배열(Jagged Array)

가변 배열(Jagged Array)은 그 배열의 배열 요소가 배열 타입인 경우를 말하는데, 각 배열 요소는 서로 다른 차원과 크기를 갖는 배열일 수 있다.
C#에서 일반 다차원 배열의 경우 [,]와 같이 콤마로 차원을 분리하는 반면, 가변배열은 [][]와 같이 "배열의 배열" 처럼 사각괄호를 겹처서 차원을 표현한다.
가변 배열은 일반 다차원 배열로 했을때 공간의 낭비가 심해지는 경우, 혹은 각차원마다 다른 배열 크기를 가져야 하는 경우 특히 유용하다.

	//Jagged Array(가변배열)
	int[][] A = new int[3][];

	//각 1차 배열 요소당 서로 다른 크기의 배열 할당
	A[0] = new int[2];
	A[1] = new int[6] {1,2,3,4,5,6};
	A[2] = new int[3] {9,8,7};


2.3 동적 배열(Dynamic Array)

배열은 일정한 크기의 연속된 배열요소들의 집합이고, 배열의 크기는 초기화시 미리 지정된다.
정적 배열(Static Array)은 이렇게 처음에 지정한 고정 크기를 그대로 계속 유지하는 배열이다.
C#에서 기본적으로 사용하는 배열 문법, 즉 int[], string[,] 같은 식으로 선언된 배열들은 모두 정적 배열에 해당한다.

하지만 배열의 최대 크기를 미리 알 수 없는 경우도 있으며, 필요시 배열을 중간에 확장해야 하는 경우도 있다.
이렇게 배열이 꽉 찼을 경우 배열을 확장하거나 반대로 배열이 너무 적은 요소를 갖을 경우 축소하는 기능을 갖는 배열을 동적 배열(Dynamic Array)이라 한다.

동적 배열을 만드는 가장 간단한 방식은 새로운 요소가 추가될 때마다 배열 크기를 하나씩 늘려나가는 것이다.
즉, 아래 예제와 같이 새 배열요소를 추가할 때 기존 배열(arr)의 크기보다 1개 더 큰 임시 배열(temp)을 생성하고, 임시 배열에 모든 요소를 복사한 후,
다시 임시 배열(temp)을 기존 배열(arr)에 할당하고, 배열 마지막 요소에 새 배열요소를 추가하는 것이다.

*Array.DynamicArray1.cs 참조

위와 같은 방식은 필요할 때마다 배열을 하나씩 동적으로 증가시키는 방식으로 꼭 필요한 공간만을 사용한다는 장점이 있지만,
매번 새로운 배열 공간을 생성하고 여기에 기존 배열요소들을 전부 복사해 넣어야 한다는 단점이 있다.

이러한 방식은 배열에 하나의 요소를 추가할 때마다 전체 기존 배열을 복사해야 하기 때문에, 배열의 크기가 n일 때 O(n)의 시간이 소요된다.
예를 들어, 배열의 크기가 1일때 새 요소를 추가하면 기존 배열 요소 1개를 복사해야 하고, 배열의 크기가 2일 때는 2개를, 3일 때는 3개를 복사해야 한다. 
이러한 방식으로 임의의 배열 크기가 n 일때, n개씩 복사하는 동작(operation)을 수행하여야 한다.

위와 같은 단점을 해결하기 위해 흔히 사용되는 동적 배열의 구현 방식은 배열을 2배씩 확장하는 것이다. 즉, 배열 확장이 필요한 경우 배열 크기가 2배인 새로운 임시 배열을 생성하고
모든 기존 배열 요소들을 새 임시 배열에 복사한 뒤 기존 배열을 해제하는 방식이다.
아래는 이러한 방식으로 구현한 동적 배열의 예제이다.

*Array.DynamicArray2.cs 참조

위 예제는 배열의 최대 수용가능 용량(Capacity)과 현재 배열요소 수(Count)를 속성으로 가지고 있으며, Count가 Capacity보다 크거나 같으면 
즉 배열이 꽉 차면, 배열을(Growth Factor만큼) 2배로 확장하고 새 배열요소를 추가하고 있다.

동적배열에서 흔히 다루는 주제 중의 하나는 성장인자(Growth Factor)인데, 이는 배열이 꽉 찼을 때, 배열을 얼마만큼 늘려야 하는가를 정하는 인자이다.
성장인자는 각 라이브러리/Framework 마다 다르지만 통상 2배 혹은 1.5배를 많이 사용한다.

위 예제의 경우 처음 배열의 크기는 16이고, 다음 확장시 32, 그 다음 확장시 64 등으로 2배씩 증가한다.
따라서, 배열인덱스 0부터 15까지는 새 요소를 추가할 때 즉시 추가되며,
17번째 요소 추가시 배열크기 32인 새 배열로 확장한 후, 16개의 기존 요소들을 복사하게 된다.
이때, 배열요소 추가수에 따른 수행시간을 그래프로 그리면 아래와 같이 된다.

*12p 이미지 참조

위 그래프에서 17번째 요소 추가의 경우, 16개의 요소 복사에 따른 수행시간이 표시되고 있다.
그런데, 이러한 16개의 복사 수행시간을 기존 첫 요소부터 16번 요소까지의 수행시간에 분할하여 분산한다면,
O(1)*2이 되어 결국 수행시간은 O(1)이 됨을 알 수 있다.
이는 33번째에서의 수행시간에도 동이라게 적용되어 결국 이 동적 배열은 요소 추가시 O(1)의 수행시간을 갖게 됨을 알 수 있다.
참고로, 이렇게 일부 수행에서 일어나는 비싼 수행 비용을 분산시켜 여러 다른 일반 수행들로 분할 상환하여 비용을 계산하는 방식을 분할상환분석(Amortized Analysis)이라 부른다.


[참고] --------------------------------------------------------------------------------------------------------------------------------------------
알고리즘의 수행시간을 대략적으로 나타내는 방법을 점근 표기법(Asymptotic Notation)이라고 하는데, 
대표적인 점근 표기법에는 Big O표기법, Big Omega표기법, Big Theta표기법이 있다.
Big O표기법은 알고리즘이 최악으로 실행될 경우의 성능을 표현할 때 사용하면 Big Omega표기법은 알고리즘이 가장 최선으로 실행될 경우의 성능을 표시한다.
그리고 Big Theta표기법은 알고리즘 성능의 상한(Big O표기법)과 하한(Big Omega 표기법)을 동시에 나타내는데 사용한다.
알고리즘의 성능을 표현하는데 가장 많이 사용하는 것은 Big O표기법으로 이는 최악의 경우 아무리 늦더라도 이 정도의 성능은 보장한다는 것을 의미한다.
Big O표기법은 "O(증가함수)"와 같이 O 뒤의 괄호 안에 증가함수를 넣는데, 증가함수란 입력 데이타의 크기 n에 대해 알고리즘의 수행시간이 늘어나는 비율을 나타내는 함수이다.

예를들어, 입력 데이타의 크기 n에 대해 수행시간이 2n²+ 3n + 4 와 같이 걸린다고 했을 때, 이는 Big O표기법으로 O(n²)처럼 표시한다.
입력 데이타의 크기 n이 계속 크게 증가할 때, 수행시간이 수식에서 가장 큰 영향을 미치는 것은 최고차항이며, 하위차항이나 각 항의 계수는 영향에 미비해 지게 된다.
알고리즘의 성능은 보통 데이타 크기가 작을 경우는 의미가 없고 데이타 크기가 크게 증가했을 때 큰 의미가 있으므로, 
Big O표기법을 사용하여 대략적인 성능을 표시할 때 최고차항과 같이 행심적인 증가 비율을 사용하게 된다.
Big O표기법으로 가주 사용되는 표현은 O(1),O(log n),O(n²),O(n³),O(2ⁿ)등인데, 가장 성능이 좋은 O(1)부터 점차적으로 낮은 성능을 표시한 것이다.
O(1)은 입력 데이타의 수가 아무리 많아지더라도 알고리즘 수행시간이 일정한 상수 시간에 완료된다는 것을 의미하는 것으로 예들 들어 
1000개의 데이타가 있던 천만 개의 데이타가 있던 데이타의 수와 상관없이 수행시간이 비슷하게 완료되는 것을 의미한다. 또 다른 예로 O(n)은 입력 데이타의 수와 동일한 비율로 수행시간이 증가한다는 것이고, 
O(n²)은 입력 데이타 크기 n에 대해 그 수의 제곱만큼의 수행시간이 더 걸린다는 것을 의미한다.
마지막으로 점근 표기법은 수행시간 뿐만 아니라 알고리즘에 소요되는 메모리 공간을 대략적으로 나타내기 위해서 사용될 수도 있다. 즉, 알고리즘이 실행되는 수행시간은 시간 복잡도(Time Complexity)로 나타내고
그에 소요되는 공ㅇ간은 공간 복잡도(Space Complexity)로 나타내는데, 이들은 점근 표기법으로 주로 Big O표기법을 사용하여 표현한다.
--------------------------------------------------------------------------------------------------------------------------------------------------

2.4 원형 배열(Circular Array)

원형 배열은 고정된 크기의 배열을 마치 양 끝이 연결된 것처럼 사용할 수 있게 한 자료구조로서, 흔히 원형 버퍼(Circular Buffer), 링 버퍼(Ring Buffer)라고도 불리운다.
즉, 배열의 크기가 N 일 때, 배열의 마지막 요소(N-1)에 도착하면, 다음 배열요소는 첫번째 요소(0)로 순환하는 구조이다.

원형 배열은 처음 들어간 데이타가 먼저 나오는 FIFO(First in first out) 구조의 데이타 버퍼에 적합하며, 비원형의 일반 배열은 마지막에 들어간 데이타가 먼저 나오는 LIFO(Last in first out) 구조의 버퍼에 적합하다.
원혁 배열은 FIFO구조를 가진 큐(Queue)를 구현하거나 데이타 스트림 버퍼 등을 구현할 때 흔히 사용되곤 한다.

아래 그림은 원형 배열으 ㅣ구조를 표현한 것인데, 8개의 요소를 갖는 배열이 원형으로 순환하는 구조를 가지고 있다.

*13p 이미지 참조

원형 배열에서 배열 자체는 고정된 크기를 갖는 일반 배열과 동일하지만, 이를 특별한 방식으로 사용하는 것이라고 할 수 있다.
원형배열은 배열을 순환하는 구조로 만들어야 하므로, 배열 인덱스를 증가시킬 때 mod연산자를 사용하여 마지막 배열의 다음 인덱스가 첫번째 인덱스로 돌아오게 한다.

C#에서 mod 연산자는 %로 표시되고 나머지를 구할 때 사용되는데, 예를 들어 10%8은 10을 8로 나눈 나머지 즉 2가된다.
이러한 mod연산자를 사용하여 원형배열의 인덱스 증가를 다음과 같이 표현할 수 있다.

	index = (index + 1) % A.Length;

위 표현식을 사용하여, A[7] 요소를 읽고 다음 요소로 이동한다면, (7 + 1) % 8 = 0 죽 A[0]배열 요소로 이동하게 된다.

원형 배열에 보다 익숙해 지기 위해 간단한 사례를 들어보자.
원형 탁자에 8명의 사람이 앉아 있다고 가정하자.
각 사람의 명칭은 위에서부터 시계 방향으로 a~h라고 가정하자.
이때, 임의의 사람을 선택해서 그 사람으로부터 시계 방향으로 모든 사람들의 명칭을 순서대로 출력하는 프로그램을 만들어 보자.

이 문제를 해결하는 간단한 방법은 abcdefgh 전체를 한번 더 추가해서 뒤에 붙이는 방식이다.
즉, abcdefghabcdefgh 와 같이 하면 임의의 시작 인덱스에서 부터 순서대로 8개를 읽으면 된다.
예를 들어 c로부터 시작한다면 ab_cdefghab_cdefgh 를 읽으면 된다.
그러나, 이러한 방식의 단점은 배열의 크기만큼 중복된 공간이 더 필요하고 현재의 배열을 중복 복사해야 한다는 점이다.
이러한 중복 복사 방식보다 더 효울적인 방식으로 원형 배열을 사용할 수 있다.
즉 배열에 a,b,c,d,e,f,g,h를 넣고 배열 인덱스를 순환하도록 조정하면, 임의의 인덱스에서 시작하여 N개를 순차적으로 출력할 수 있다.
아래 예제는 이를 구현한 샘플이다.

	char[] A= "abcdefgh".ToCharArray();
	int startIndex = 2;

	for(int i=0; i < A.Length; i++)
	{
		int index = (startIndex + i) % A.Length;
		Console.Write(A[index]);
	}


2.5 .NET의 배열 클래스
.NET Framework은 고정 배열과 동적 배열을 지원한다.
.MET의 고정 배열은 1차원 배열부터 32차원 배열까지 지원하고, 디폴드로 배열은 최대 2GB까지의 크기를 가질 수 있다.
단, 64bit환경에서는 app.config에서 gcAllowVeryLargeObjects 값을 enable하면 2GB보다 큰 배열을 가질 수 있다.
.NET의 고정 배열은 모두 System.Array 추상 클래스로부터 파생되는데, 이 클래스는 컴파일러나 시스템에서만 파생클래스를 만들 수 있기 때문에,
개발자가 System.Array로부터 직접 파생클래스를 만들 수는 없다.

.NET Framework에서 동적 배열을 지원하는 클래스로는 ArrayList와 List<T>가 있다.
ArrayList는 object타입의 동적 배열을 가지며, List<T>는 ㅐ발자가 임의의 타입(T)을 지정할 수 있는 Generic 타입의 동적 배열이다.
예를 들어, List<int>는 정수형 동적 배열이며, List<string>는 문자열 동적 배열이다.

아래 예제는 List<int> 동적배열에 1부터 17까지의 숫자를 차례대로 넣어 본 것으로, 이 동적 배열은 초기 배열 크기가 4이먀, 8,16,32, ... 등으로 2배씩 증가함을 볼 수 있다.

	List<int> a = new List<int>();
	for(int i=0; i<=17; i++)
	{
		a.Add(i);
		Console.WriteLine("{0}: {1}", i, a.Capacity);
	}