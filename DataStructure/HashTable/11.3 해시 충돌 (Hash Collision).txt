11.3 해시 충돌 (Hash Collision)

해싱에서 복수 개의 Key가 동일한 Bucket 주소를 가리킬 때 해시 충돌이 발생한다.
이러한 해시 충돌을 해결하기 위해 여러 가지 방법이 사용될 수 있는데, 일반적으로 크게 체이닝(Chaining) 방식과 개방 주소법(Open Addressing) 방식을 사용하여 이러한 해시 충돌 문제를 처리한다.

Chaining 방식

해시 충돌 문제를 해결하는 하나의 방식으로 Bucket 안에 하나의 엔트리만 저장하는 것이 아니라 일종의 리스트를 사용하여 하나의 Bucket 인덱스에 여러 개의 엔트리가 연결되어 들어가도록 하는 방법이 있다.
즉, 동일한 Bucket 주소에 복수 개의 엔트리 노드가 체인처럼 연결되는 구조로서 이를 Separate Chaining 방식이라 한다.

Separate Chaining 방식에서 가장 일반적인 구조는 Bucket에 연결리스트 노드를 체인처럼 계속해서 연결해 나가는 방식이다.
즉, 특정 인덱스의 Bucket은 첫 연결리스트 노드를 가리키고, 이 노드가 다음 노드를 연결하는 방식을 취한다.
Bucket의 연결 리스트에 새로운 엔트리를 추가하는 방식으로는 맨 마지막에 추가하는 것보다 Bucket 링크의 맨 앞에 삽입하는 방법이 더 효율적이다.
아래 그림은 연결리스트를 사용한 Separate Chaining 방식을 표현한 것이다.


						Separate Chaining


		 Key			   Buckets

						┌─┐┌─┐
						│ 0││  │
	   김인수 ─┐		├─┤├─┤				연결 리스트
				│		│ 1││  │
				│		├─┤├─┤┌─→ | ● | 박민규 | 2643-2231
				│┌┬→│ 2││●─┘	     ↓
	   박민규 ─│┘│	├─┤├─┤       |    | 이강수 | 3451-5953
				│	│	│ 3││  │
				│	│	├─┤├─┤
	   이강수 ─│─┘	│ 4││  │
				│		├─┤├─┤
				└──→│ 5││●───→ |	| 김인수 | 3643-1932
						├─┤├─┤
						│ 6││  │
	   강민주 ──┐	├─┤├─┤
				  └─→│ 7││●───→ |	| 강민주 | 2612-3245
						└─┘└─┘


Separate Chaining 방식에서 연결리스트(Linked List)를 사용하는 것이 아니라 대안적으로 이진 탐색 트리(Binary Search Tree) 혹은 동적 배열(Dynamic Array) 등을 사용할 수도 있다.
이진 탐색 트리를 사용하는 이유는 연결리스트(Linked List)에서 특정 Key를 검색하는데 O(n)의 시간이 걸리기 때문에 이를 O(log n)으로 줄이기 위함인데, 트리 자체를 관리하는 오버헤드가 있다는 단점이 있다.


Open Addressing 방식

개방 주소법(Open Addressing) 방식은 Key에 상응하는 Bucket이 이미 차 있을 때, Bucket 배열을 일정한 간격으로 이동하면서 이용 가능한 다음 Bucket 위치를 찾아 사용하는 방법이다. 
Chaining 방식에서는 한 Bucket에 여러 엔트리가 들어갈 수 있지만, Open Addressing 방식에서는 한 Bucket 당 하나의 엔트리만 들어갈 수 있다.

Open Addressing 방식으로 다음 Bucket을 찾아가는 방식으로는 다음과 같은 방식들이 있다.

	- 선형 탐사(Linear Probing): 현재 Bucket 위치에서 고정된 크기(보통 1)만큼 다음 위치로 이동하면서 빈 Bucket을 탐사하는 방식

	- 이차 탐사(Quadratic Probing): 현재 Bucket 위치에서 1²(=1), 2²(=4), 3²(=9), ... 만큼씩 이동하면서 빈 Bucket을 탐사하는 방식

	- 이중 해싱(Double Hashing): 해시 함수를 2개 준비하여, 첫번째 해시 함수는 처음 Bucket 해싱에 사용하고, 두번째 해시 함수는 해시 충돌시 다음 Bucket 위치를 계산하는데 사용한다.
								선형 탐사나 이차 탐사의 경우 지정된 간격만큼 이동하는데, 이중 해싱에서는 이 간격을 두번째 해시함수를 써서 산출하게 된다.
								예를 들어, 2개의 해시함수가 h1, h2라 하고 i번째 탐사를 계속한다면, Bucket 위치는 (h1(key) + i * h2(key)) % bucketSize 와 같이 계산될 수 있다.

Chaining 방식은 거의 무제한으로 엔트리를 추가할 수 있지만, Open Addressing 방식은 물리적으로 Bucket 배열의 크기만큼만 엔트리를 추가할 수 있다.
실제 사용하는 Key 갯수를 Bucket 배열의 크기로 나눈 값을 Load Factor 라고 하는데, 이 값이 0.7 이상이되면 전체 해시테이블에 성능이 크게 저하될 수 있다.
이 경우 Bucket 배열을 확장하고 기존 엔트리들을 재해싱(Rehashing)하여 확장된 배열에 넣어 주는 방법을 사용할 수 있다.

일반적으로 Open Addressing 방식은 Load Factor가 작고 엔트리의 사이즈가 작은 경우 적합하고, Chaining 방식은 Load Factor가 크고 엔트리 사이즈가 큰 경우 혹은 데이타 크기가 가변적인 경우에 더 적합하다.