5.5 스택의 활용 - 수식계산

스택은 다양한 분야에 활동되는데, 여기서는 수식 계산에 스택을 활용하는 과정을 살펴본다.
수식(Expression)은 연산자(Operator)와 연산자(Operand)로 구성되어 있는데, 연산자의 위치에 따라 전위표기(Prefix Notation), 중위표기(Infix Notation), 후위표기(Postfix Notation)로 표현할 수 있다.

예를 들어, 수식 "1 + 22"는 각 표기법에 따라 다음과 같이 표현할 수 있다.

	전위표기 : + 1 22
	중위표기 : 1 + 22
	후위표기 : 1 22 +
	
사람들이 사용하는 수식 표기법은 중위표기법인데, 컴퓨터에서 중위표기를 사용하면 여러가지 불편한 점이 있다.
중위표기법은 괄호와 연산자 우선순위를 고려해서 처리해야 하지만, 후위표기법은 괄호나 우선순위가 따로 없으면 왼쪽에서 오른쪽으로 순서대로 처리하면 된다.
컴퓨터에서 수식을 처리할 때는 후위표기법이 가장 효율적이다.

수식은 여러가지 복잡한 연산을 표현할 수 있는데, 여기서는 간단하게 사칙연산만을 처리하는 과정에 대해 살펴보자.
수식을 처리하는 프로그램은 보통 아래와 같이 3가지 부분으로 나누어 질 수 있다.

	1. 먼저 수식을 문자열로 받아들여 이를 토큰화(Tokenize)하는 부분인데, 일반적으로 연산자, 피연산자, 괄호 등을 분석해서 토큰 컬렉션으로 만든다.
	   토큰화 과정을 거친 토큰은 보통 토큰타입(Token type)과 토큰값(Token value)을 갖는다.
	   예를 들어, 수식 "1 + 22"는 3개의 토큰(즉1, +, 22)을 갖게 된다.
	2. 다음으로 중위표기가 되어 있는 것을 스택을 활용하여 후위표기로 변환하는 부분이다.
	3. 마지막으로 후휘표기가 되어 있는 부분을 스택을 사용하여 계산하는 부분이다.
	
수식 계산에서 스택을 활용하는 부분에 포커스하기 위해, 여기서는 토큰화하는 부분은 생략하고, 중위표기를 후위표기로 변환 후 후위표기로부터 식을 계산하는 부분만 살펴보도록 하자.

중위표기를 후위표기로 변환하는 로직은 다음과 같다.

	1. 후위표기 결과를 담는 리스트(이하 postfix)를 초기화한다.

	2. 연산자를 저장할 수 있는 스택을 초기화한다.

	3. 중위표기로 표현된 토큰들을 루프를 돌며 아래 로직에 따라 하나씩 처리한다.
		- 토큰이 피연산자이면, postfix에 추가한다.
		
		- 토큰이 연산자이면, 스택의 최상위 노드에 있는 연산자가 토큰 연산자보다 우선순위가 높거나 같으면 스택에 팝 하여 postfix에 추가한다.
		  이 과정을 반복해서 스택의 토큰 연산자보다 우선순위가 낮은 연산자가 있거나 스택이 빌 때까지 계속 수행한다.
		  우선순위는 괄호 '(', ')' 가 가장 낮고, 다음이 +,- 그리고 다음으로 *,/ 가 가장 높다.
		  예를들어, 토큰이 + 혹은 - 이면, 스택에서 *,/,+,- 연산자가 있는 경우 모두 Pop한다.
		  만약 토큰이 * 혹은 - 이면, 스택에서 *,/ 연산자인 경우만 Pop한다.
	    
		- 토큰이 '(' 괄호이면, 스택에 추가한다.
		
		- 토큰이 ')' 괄호이면, 스택에서 '(' 이 나올 때까지 계속 Pop하여 postfix에 추가한다.
		  단 스택에 있는 '(' 은 postfix에 추가하지 않는다.

	4. 중위표기로 포현된 토큰들을 모두 처리한 후, 스택에 남은 연산자를 모두 postfix에 추가한다.
	
이어 후위표기로부터 식을 계산하는 부분은 좀 더 간단하다.
아래는 스택을 이용하여 후위표기로부터 식을 계산하는 기본 로직이다.

	1. 피연산자 또는 결과를 저장할 수 있는 스택을 미리 생성한다.

	2. 후위표기 식을 왼쪽에서부터 오른쪽으로 토큰 단위로 하나씩 처리한다.

	3. 토큰이 피연산자이면 스택에 추가한다.

	4. 토큰이 연산자이면 스택에서 이미 넣어둔 2개의 피연산자를 꺼내 연산한 후 결과를 다시 스택에 넣는다.

	5. 위 과정을 반복하면 마지막에 최종 결과만 스택에 남게된다. 이를 Pop 하여 최종결과를 리턴한다.

	
위에서 소개한 후위표기 변환과 식 계산 로직을 토대로 아래와 같이 간단한 사칙연산 프로그램을 작성할 수 있다.
토큰화 과정을 생략하였기 때문에 테스트 코드에서 샘플에 사용한 식은 각 토큰 사이에 공백을 넣어 간단한 토큰 배열로 만들수 있게 하였다.

*Stack.Calculator.cs 및 Evalute(), ConvertToPostfix(), Calc 메서드, Stack.Example.cs 및 Example2() 메서드 참조